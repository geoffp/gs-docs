<!DOCTYPE html>
<html>
<head>
  <meta content="HTML Tidy for HTML5 for Apple macOS version 5.8.0"
  name="generator">
  <title>6502.org: Tutorial: 65C816 Opcodes</title>
  <meta content="text/html; charset=utf-8" http-equiv=
  "Content-Type">
  <meta content=
  "Detailed discussion of the behaviour of the 65816, by Bruce Clark."
  name="description">
  <style type="text/css">
  li.c3 {display:block}
  span.c2 {font-size: 80%}
  span.c1 {font-size: 120%}
  </style>
  <meta content="width=device-width, initial-scale=1" name=
  "viewport">
  <link href="./index.css" rel="stylesheet">
  <script src="./index.js" type="module"></script>
</head>
<body>
  <header>
    <h1>65C816 Opcodes</h1>
    <address>
      by Bruce Clark
    </address>
  </header>
  <search-bar></search-bar>
  <aside class="right">
    Thanks to everyone who read over the early draft. Thanks to
    BigEd for the helpful feedback.
  </aside>
  <nav>
    <h3>Table of contents:</h3>
    <ul>
      <li class="lvl-0">
        <a href="#1"><span class="section-number">1</span>
        <span class="section-name">Introduction</span></a>
      </li>
      <li class="lvl-0">
        <a href="#2"><span class="section-number">2</span>
        <span class="section-name">Modes and Memory
        Organization</span></a>
      </li>
      <li class="lvl-0">
        <a href="#3"><span class="section-number">3</span>
        <span class="section-name">A Note On 65C816 Assemblers and
        Immediate Data</span></a>
      </li>
      <li class="lvl-0">
        <a href="#4"><span class="section-number">4</span>
        <span class="section-name">Registers and Flags</span></a>
      </li>
      <li class="lvl-0">
        <a href="#5"><span class="section-number">5</span>
        <span class="section-name">Addressing Modes</span></a>
      </li>
      <li class="lvl-1">
        <a href="#5.1"><span class="section-number">5.1</span>
        <span class="section-name">Page and Bank Boundary
        Wrapping</span></a>
      </li>
      <li class="lvl-1">
        <a href="#5.1.1"><span class="section-number">5.1.1</span>
        <span class="section-name">Page Boundary
        Wrapping</span></a>
      </li>
      <li class="lvl-1">
        <a href="#5.1.2"><span class="section-number">5.1.2</span>
        <span class="section-name">Bank Boundary
        Wrapping</span></a>
      </li>
      <li class="lvl-1">
        <a href="#5.1.3"><span class="section-number">5.1.3</span>
        <span class="section-name">Notation</span></a>
      </li>
      <li class="lvl-1">
        <a href="#5.2"><span class="section-number">5.2</span>
        <span class="section-name">Absolute</span></a>
      </li>
      <li class="lvl-1">
        <a href="#5.3"><span class="section-number">5.3</span>
        <span class="section-name">Absolute,X and
        Absolute,Y</span></a>
      </li>
      <li class="lvl-1">
        <a href="#5.4"><span class="section-number">5.4</span>
        <span class="section-name">(Absolute) and
        [Absolute]</span></a>
      </li>
      <li class="lvl-1">
        <a href="#5.5"><span class="section-number">5.5</span>
        <span class="section-name">(Absolute,X)</span></a>
      </li>
      <li class="lvl-1">
        <a href="#5.6"><span class="section-number">5.6</span>
        <span class="section-name">Accumulator</span></a>
      </li>
      <li class="lvl-1">
        <a href="#5.7"><span class="section-number">5.7</span>
        <span class="section-name">Direct</span></a>
      </li>
      <li class="lvl-1">
        <a href="#5.8"><span class="section-number">5.8</span>
        <span class="section-name">Direct,X and Direct,Y</span></a>
      </li>
      <li class="lvl-1">
        <a href="#5.9"><span class="section-number">5.9</span>
        <span class="section-name">(Direct)</span></a>
      </li>
      <li class="lvl-1">
        <a href="#5.10"><span class="section-number">5.10</span>
        <span class="section-name">[Direct]</span></a>
      </li>
      <li class="lvl-1">
        <a href="#5.11"><span class="section-number">5.11</span>
        <span class="section-name">(Direct,X)</span></a>
      </li>
      <li class="lvl-1">
        <a href="#5.12"><span class="section-number">5.12</span>
        <span class="section-name">(Direct),Y</span></a>
      </li>
      <li class="lvl-1">
        <a href="#5.13"><span class="section-number">5.13</span>
        <span class="section-name">[Direct],Y</span></a>
      </li>
      <li class="lvl-1">
        <a href="#5.14"><span class="section-number">5.14</span>
        <span class="section-name">Immediate</span></a>
      </li>
      <li class="lvl-1">
        <a href="#5.15"><span class="section-number">5.15</span>
        <span class="section-name">Implied</span></a>
      </li>
      <li class="lvl-1">
        <a href="#5.16"><span class="section-number">5.16</span>
        <span class="section-name">Long</span></a>
      </li>
      <li class="lvl-1">
        <a href="#5.17"><span class="section-number">5.17</span>
        <span class="section-name">Long,X</span></a>
      </li>
      <li class="lvl-1">
        <a href="#5.18"><span class="section-number">5.18</span>
        <span class="section-name">Relative8 and
        Relative16</span></a>
      </li>
      <li class="lvl-1">
        <a href="#5.19"><span class="section-number">5.19</span>
        <span class="section-name">Source,Destination</span></a>
      </li>
      <li class="lvl-1">
        <a href="#5.20"><span class="section-number">5.20</span>
        <span class="section-name">Stack,S</span></a>
      </li>
      <li class="lvl-1">
        <a href="#5.21"><span class="section-number">5.21</span>
        <span class="section-name">(Stack,S),Y</span></a>
      </li>
      <li class="lvl-1">
        <a href="#5.22"><span class="section-number">5.22</span>
        <span class="section-name">Page and Bank Boundary Wrapping
        Of The Stack</span></a>
      </li>
      <li class="lvl-1">
        <a href="#5.23"><span class="section-number">5.23</span>
        <span class="section-name">A Note On Operand
        Addresses</span></a>
      </li>
      <li class="lvl-0">
        <a href="#6"><span class="section-number">6</span>
        <span class="section-name">Instructions</span></a>
      </li>
      <li class="lvl-1">
        <a href="#6.1.1.1"><span class=
        "section-number">6.1.1.1</span> <span class=
        "section-name"><code>ADC</code> <code>SBC</code></span></a>
      </li>
      <li class="lvl-1">
        <a href="#6.1.1.2"><span class=
        "section-number">6.1.1.2</span> <span class=
        "section-name"><code>CMP</code> <code>CPX</code>
        <code>CPY</code></span></a>
      </li>
      <li class="lvl-1">
        <a href="#6.1.1.3"><span class=
        "section-number">6.1.1.3</span> <span class=
        "section-name"><code>DEC</code> <code>DEX</code>
        <code>DEY</code> <code>INC</code> <code>INX</code>
        <code>INY</code></span></a>
      </li>
      <li class="lvl-1">
        <a href="#6.1.2.1"><span class=
        "section-number">6.1.2.1</span> <span class=
        "section-name"><code>AND</code> <code>EOR</code>
        <code>ORA</code></span></a>
      </li>
      <li class="lvl-1">
        <a href="#6.1.2.2"><span class=
        "section-number">6.1.2.2</span> <span class=
        "section-name"><code>BIT</code></span></a>
      </li>
      <li class="lvl-1">
        <a href="#6.1.2.3"><span class=
        "section-number">6.1.2.3</span> <span class=
        "section-name"><code>TRB</code> <code>TSB</code></span></a>
      </li>
      <li class="lvl-1">
        <a href="#6.1.3"><span class="section-number">6.1.3</span>
        <span class="section-name"><code>ASL</code>
        <code>LSR</code> <code>ROL</code>
        <code>ROR</code></span></a>
      </li>
      <li class="lvl-1">
        <a href="#6.2.1.1"><span class=
        "section-number">6.2.1.1</span> <span class=
        "section-name"><code>BCC</code> <code>BCS</code>
        <code>BEQ</code> <code>BMI</code> <code>BNE</code>
        <code>BPL</code> <code>BRA</code> <code>BVC</code>
        <code>BVS</code></span></a>
      </li>
      <li class="lvl-1">
        <a href="#6.2.1.2"><span class=
        "section-number">6.2.1.2</span> <span class=
        "section-name"><code>BRL</code></span></a>
      </li>
      <li class="lvl-1">
        <a href="#6.2.2.1"><span class=
        "section-number">6.2.2.1</span> <span class=
        "section-name"><code>JMP</code> <code>JSL</code>
        <code>JSR</code></span></a>
      </li>
      <li class="lvl-1">
        <a href="#6.2.2.2"><span class=
        "section-number">6.2.2.2</span> <span class=
        "section-name"><code>RTL</code> <code>RTS</code></span></a>
      </li>
      <li class="lvl-1">
        <a href="#6.3.1"><span class="section-number">6.3.1</span>
        <span class="section-name"><code>BRK</code>
        <code>COP</code></span></a>
      </li>
      <li class="lvl-1">
        <a href="#6.3.1.1"><span class=
        "section-number">6.3.1.1</span> <span class=
        "section-name">Hardware Interrupts</span></a>
      </li>
      <li class="lvl-1">
        <a href="#6.3.2"><span class="section-number">6.3.2</span>
        <span class="section-name"><code>RTI</code></span></a>
      </li>
      <li class="lvl-1">
        <a href="#6.4.1"><span class="section-number">6.4.1</span>
        <span class="section-name"><code>CLC</code>
        <code>CLD</code> <code>CLI</code> <code>CLV</code>
        <code>SEC</code> <code>SED</code>
        <code>SEI</code></span></a>
      </li>
      <li class="lvl-1">
        <a href="#6.4.2"><span class="section-number">6.4.2</span>
        <span class="section-name"><code>REP</code>
        <code>SEP</code></span></a>
      </li>
      <li class="lvl-1">
        <a href="#6.5"><span class="section-number">6.5</span>
        <span class="section-name"><code>LDA</code>
        <code>LDX</code> <code>LDY</code> <code>STA</code>
        <code>STX</code> <code>STY</code>
        <code>STZ</code></span></a>
      </li>
      <li class="lvl-1">
        <a href="#6.6"><span class="section-number">6.6</span>
        <span class="section-name"><code>MVN</code>
        <code>MVP</code></span></a>
      </li>
      <li class="lvl-1">
        <a href="#6.7"><span class="section-number">6.7</span>
        <span class="section-name"><code>NOP</code>
        <code>WDM</code></span></a>
      </li>
      <li class="lvl-1">
        <a href="#6.8.1"><span class="section-number">6.8.1</span>
        <span class="section-name"><code>PEA</code>
        <code>PEI</code> <code>PER</code></span></a>
      </li>
      <li class="lvl-1">
        <a href="#6.8.2"><span class="section-number">6.8.2</span>
        <span class="section-name"><code>PHA</code>
        <code>PHX</code> <code>PHY</code> <code>PLA</code>
        <code>PLX</code> <code>PLY</code></span></a>
      </li>
      <li class="lvl-1">
        <a href="#6.8.3"><span class="section-number">6.8.3</span>
        <span class="section-name"><code>PHB</code>
        <code>PHD</code> <code>PHK</code> <code>PHP</code>
        <code>PLB</code> <code>PLD</code>
        <code>PLP</code></span></a>
      </li>
      <li class="lvl-1">
        <a href="#6.9"><span class="section-number">6.9</span>
        <span class="section-name"><code>STP</code>
        <code>WAI</code></span></a>
      </li>
      <li class="lvl-1">
        <a href="#6.10.1"><span class=
        "section-number">6.10.1</span> <span class=
        "section-name"><code>TAX</code> <code>TAY</code>
        <code>TSX</code> <code>TXA</code> <code>TXS</code>
        <code>TXY</code> <code>TYA</code>
        <code>TYX</code></span></a>
      </li>
      <li class="lvl-1">
        <a href="#6.10.2"><span class=
        "section-number">6.10.2</span> <span class=
        "section-name"><code>TCD</code> <code>TCS</code>
        <code>TDC</code> <code>TSC</code></span></a>
      </li>
      <li class="lvl-1">
        <a href="#6.10.3"><span class=
        "section-number">6.10.3</span> <span class=
        "section-name"><code>XBA</code></span></a>
      </li>
      <li class="lvl-1">
        <a href="#6.10.4"><span class=
        "section-number">6.10.4</span> <span class=
        "section-name"><code>XCE</code></span></a>
      </li>
      <li class="lvl-0">
        <a href="#APPENDIX:"><span class=
        "section-number">APPENDIX:</span> <span class=
        "section-name">Emulation Mode</span></a>
      </li>
    </ul>
  </nav>
  <section>
    <h3><a id="1" name="1">1 Introduction</a></h3>
    <p>The 65C816 is a member of the 6502 microprocessor family,
    capable of addressing 16 megabytes of memory (i.e. 24-bit
    addressing), with instructions that operate on 8-bit and 16-bit
    data. It also includes an emulation mode for executing 65C02
    and NMOS 6502 code.</p>
  </section>
  <section>
    <h3><a id="2" name="2">2 Modes and Memory Organization</a></h3>
    <p>Both the 65C02 and the NMOS 6502 have two modes: binary mode
    and decimal mode; <code>ADC</code> and <code>SBC</code>
    instructions use binary arithmetic in binary mode and
    <code>BCD</code> (Binary Coded Decimal) arithmetic in decimal
    mode. The 65C816 has 10 combinations of modes of which binary
    mode and decimal mode are a part.</p>
    <p>Also a part of these combinations are the width (8 or 16
    bits) of the accumulator (and read-modify-write memory
    instructions, such as <code>DEC</code>), the width of the X and
    Y index registers (likewise, 8 or 16 bits), and native or
    emulation mode. The 10 combinations are:</p>
    <ul>
      <li>Binary Mode, Emulation Mode</li>
      <li>Binary Mode, Native Mode, 8-Bit Accumulator Mode, 8-Bit
      Index Register Mode</li>
      <li>Binary Mode, Native Mode, 8-Bit Accumulator Mode, 16-Bit
      Index Register Mode</li>
      <li>Binary Mode, Native Mode, 16-Bit Accumulator Mode, 8-Bit
      Index Register Mode</li>
      <li>Binary Mode, Native Mode, 16-Bit Accumulator Mode, 16-Bit
      Index Register Mode</li>
      <li>Decimal Mode, Emulation Mode</li>
      <li>Decimal Mode, Native Mode, 8-Bit Accumulator Mode, 8-Bit
      Index Register Mode</li>
      <li>Decimal Mode, Native Mode, 8-Bit Accumulator Mode, 16-Bit
      Index Register Mode</li>
      <li>Decimal Mode, Native Mode, 16-Bit Accumulator Mode, 8-Bit
      Index Register Mode</li>
      <li>Decimal Mode, Native Mode, 16-Bit Accumulator Mode,
      16-Bit Index Register Mode</li>
    </ul>
    <p>In emulation mode, both the accumulator (and memory) width
    and the index register width are always 8 bits, which is why
    there are 10 combinations (rather than 16 combinations). As on
    the 65C02 and NMOS 6502, <code>ADC</code> and <code>SBC</code>
    use binary arithmetic in binary mode, and <code>BCD</code>
    arithmetic in decimal mode. Whether instructions such as
    <code>ASL</code>, <code>CMP</code>, and <code>CPX</code>
    operate on 8-bit or 16-bit data depends on the accumulator (and
    memory) width (for <code>ASL</code> and <code>CMP</code>) or
    the index register width (for <code>CPX</code>). In emulation
    mode, as its name implies, the 65C816 emulates the operation of
    a 65C02 (albeit with the cycle counts of NMOS 6502). In native
    mode, the 65C816 can operate on 16-bit data, and the stack can
    be up to 64k (as compared to the 256 byte stack of the 65C02
    and NMOS 6502).</p>
    <p>The 65C816 is little endian, meaning the low byte is the
    lower address and the high(er) byte is the next address. For
    example, if:</p>
    <ul>
      <li><code>$123456</code> Contains <code>$Ab</code></li>
      <li><code>$123457</code> Contains <code>$Cd</code></li>
    </ul>
    <p class="added">then a <code>LDA</code> <code>$123456</code>
    (when in 16-bit accumulator mode) puts <code>$CDAB</code> into
    the accumulator. This byte order applies everywhere, e.g. a
    <code>LDA</code> <code>$123456</code> instruction assembles as
    <code>$AF</code> <code>$56</code> <code>$34</code>
    <code>$12</code>, <code>JSR</code> pushes the return address
    onto the stack in such a way that the lower 8 bits will be at
    at the lower address and the upper 8 bits will be at the higher
    address, etc.</p>
    <p>The 65C02 and NMOS 6502 have a 64k address space, which is
    subdivided into 256 pages; each page, therefore is 256 bytes.
    In general, cycle counts are affected when a page boundary is
    crossed (e.g. <code>LDA</code> <code>$1234</code>,X takes 4
    cycles when X is 0, but takes 5 cycles when X is
    <code>$FF</code>). Also, the zero page and the stack wrap at
    page boundaries (e.g. when X is 1, <code>LDA</code>
    <code>$FF</code>,X is equivalent to <code>LDA</code>
    <code>$0000</code> rather than <code>LDA $0100)</code>.</p>
    <p>On the 65C816, a page is still defined as 256 bytes, and a
    bank is defined as 64k bytes. In emulation mode, the behavior
    of the 65C02 and NMOS 6502 is (generally) preserved, but in
    native mode, there is no wrapping at page boundaries, and page
    boundary crossings don't affect cycle counts in as many cases
    as the 65C02 and NMOS 6502. On the 65C816, bank boundary
    crossings don't affect cycle counts, but there are a number of
    things that wrap at bank boundaries. Specifics are described
    below (including exceptions to the general behavior mentioned
    above).</p>
  </section>
  <section>
    <h3><a id="3" name="3">3 A Note On 65C816 Assemblers and
    Immediate Data</a></h3>
    <p>Most microprocessors whose instructions can operate on two
    or more data widths (e.g. 8-bit data and 16-bit data) use
    different opcodes for different data widths (of the same
    operation, such as addition). By contrast, on the 65C816, the
    same opcode is used for both 8-bit and 16-bit data, and the
    data width is determined by a processor mode, rather than the
    opcode. For example, the instruction <code>XOR</code>
    <code>$123456</code> (which assembles to the bytes
    <code>$4F</code> <code>$56</code> <code>$34</code>
    <code>$12</code>) is an 8-bit exclusive-or operation in 8-bit
    accumulator mode, and a 16-bit exclusive-or operation in 16-bit
    accumulator mode.</p>
    <p>One ramification is that 8-bit immediate data and 16-bit
    immediate data also use the same opcode. For example, the
    opcode A9 is <code>LDA</code> immediate and the next one or two
    bytes will be the immediate data depending on the accumulator
    mode. So, in 16-bit accumulator mode, A9 01 0A is the 16-bit
    instruction <code>LDA</code> <code>#$0A01</code>, and in 8-bit
    accumulator mode A9 01 0A is a pair of 8-bit instructions,
    namely:</p>
    <pre>
LDA #$01
ASL
</pre>
    <p>Consequently, all 65C816 assemblers have the ability to
    explicitly specify the width of immediate data, since an
    instruction such as <code>LDA</code> #0 must assemble as two
    bytes if it is to be executed in 8-bit mode, and must assemble
    as three bytes if it is to be executed in 16-bit mode. However,
    different assemblers have different approaches for specifying
    immediate data width. Consider the following code:</p>
    <pre>
           CLC            ; set native mode
           XCE            ; "
           REP #$30       ; 16-bit accumulator and index registers
           LDA #0         ; this needs to be assembled as three bytes
           JSR SUBROUTINE
           SEP #$30       ; 8-bit accumulator and index registers
           LDX #0         ; this needs to be assembled as two bytes
           RTS
; Note: this subroutine is CALLED from 16-bit index register mode
SUBROUTINE LDY #0         ; this needs to be assembled as three bytes
           RTS
</pre>
    <p>One of the most common approaches is to have one or more
    assembler directives for specifying the width. For example:</p>
    <ul>
      <li>.M8 ; 8-Bit Accumulator Immediate Data</li>
      <li>.M16 ; 16-Bit Accumulator Immediate Data</li>
      <li>.X8 ; 8-Bit Index Register Immediate Data</li>
      <li>.X16 ; 16-Bit Index Register Immediate Data</li>
    </ul>
    <p class="added">or:</p>
    <ul>
      <li>.Mx 16 ; 16-Bit Accumulator Immediate Data</li>
      <li>.Mx ,8 ; 8-Bit Index Register Immediate Data</li>
      <li>.Mx 8,16 ; 8-Bit Accumulator, 16-Bit Index Register
      Immediate Data</li>
    </ul>
    <p>It is important to remember that these directives do not
    actually generate any code that will change the data width.
    They only tell the assembler whether subsequent immediate data
    should be assembled as two or three bytes.</p>
    <p>You may find it useful to define a set of macros (with
    readable names) that generate a 65C816 instruction to switch
    data widths and issue an assembler directive. For example:</p>
    <pre>
.macro acc8
       SEP #$20 ; put the 65C816 in 8-bit accumulator mode
      .m8       ; tell the assembler about it
.endmacro
</pre>
    <pre>
.macro accindex8
       SEP #$30 ; put the 65C816 in 8-bit accumulator and index register mode
      .m8       ; tell the assembler about it
      .x8       ; "
.endmacro
</pre>
    <p class="added">and so on.</p>
    <p>A variation of this approach is for the assembler to attempt
    to "follow along" and switch automatically when a
    <code>REP</code> or <code>SEP</code> instruction is assembled
    (it might also look for a <code>SEC</code> <code>XCE</code>
    sequence that puts the 65C816 in emulation mode which uses
    8-bit data exclusively). The previous directive(s) are also
    provided to allow the user to override the assembler. For
    example in the earlier example code, an assembler can easily
    assemble the <code>LDA</code> and <code>LDX</code> instructions
    correctly, automatically switching to the correct width after
    encountering the <code>REP</code> and <code>SEP</code>
    instructions. However, correctly assembling the
    <code>LDY</code> instruction and cases like it can get far more
    complicated. For cases like that, it is usually up to the
    programmer to supply the correct assembler directive before the
    <code>LDY</code> to get the assembler into the correct mode;
    the assembler might simply switch to 8-bit mode at the
    <code>SEP</code>, then simply remain in 8-bit mode when it
    reached the <code>LDY</code> instruction. A "following along"
    feature can be convenient, but it can also lead to errors that
    are difficult to find.</p>
    <p>A different approach is for the assembler to use different
    operand syntaxes for 8-bit immediate data and 16-bit immediate
    data. For example:</p>
    <ul>
      <li><code>LDA</code> #0 ; the # means assemble a two byte
      instruction</li>
      <li><code>LDA</code> ##0 ; the ## means assemble a three byte
      instruction</li>
    </ul>
    <p class="added">A common source of errors is assembling the
    wrong immediate data width. Be sure to consult the
    documentation for your assembler to learn how it handles
    immediate data. You may find it worthwhile to spend some time
    searching and/or experimenting to find an assembler that fits
    your programming style.</p>
  </section>
  <section>
    <h3><a id="4" name="4">4 Registers and Flags</a></h3>
    <p>On the 65C02 and NMOS 6502 all registers and flags have
    unique one-letter names (with the exception of the Program
    Counter (PC)). On the 65C816, unfortunately, this is not the
    case. For example, there is a D register and a d flag. The D in
    the name of the <code>CLD</code> instruction refers to the D
    flag, but the D in the name of the <code>TCD</code> instruction
    refers to the D register. More unfortunate is that the term B
    register is ambiguous; it could refer to either of two
    registers: the B accumulator or the Data Bank Register
    (<code>DBR</code>). (As a further source of confusion, there is
    also a b flag.) For example, the B in the name of the
    <code>XBA</code> instruction refers to the B accumulator, but
    the B in the name of the <code>PHB</code> instruction refers to
    the <code>DBR</code>. The convention used in this document is
    to use lower case names for flags and upper case names for
    registers. Also, at the risk of being excessively verbose,
    terms such as "d flag" and "D register" will be used, in the
    belief that clarity is more helpful than succinctness.
    Likewise, in the interests of clarity, the terms "B
    accumulator" and "<code>DBR</code>" will be used to avoid
    ambiguity. Furthermore, there are times when it will be useful
    to refer specifically to the upper 8 bits and lower 8 bits of a
    16-bit register, so terms will be defined for this purpose.</p>
    <p>There are 9 registers. They are:</p>
    <ul>
      <li>The Accumulator (16 Bits Wide)</li>
      <li>The Data Bank Register (8 Bits Wide)</li>
      <li>The Direct Register (16 Bits Wide)</li>
      <li>The Program Bank Register (8 Bits Wide)</li>
      <li>The Program Counter (16 Bits Wide)</li>
      <li>The Processor Status Register (8 Bits Wide)</li>
      <li>The Stack Pointer (16 Bits Wide)</li>
      <li>The X Index Register (16 Bits Wide)</li>
      <li>The Y Index Register (16 Bits Wide)</li>
    </ul>
    <p class="added">There are 10 flags. Each is one bit wide. They
    are:</p>
    <ul>
      <li>The Break Flag</li>
      <li>The Carry Flag</li>
      <li>The Decimal Mode Flag</li>
      <li>The Emulation Mode Flag</li>
      <li>The Interrupt Disable Flag</li>
      <li>The Accumulator and Memory Width Flag</li>
      <li>The Negative Flag</li>
      <li>The Overflow Flag</li>
      <li>The Index Register Width Flag</li>
      <li>The Zero Flag</li>
    </ul>
    <p class="added">The terms used for these registers and flags
    will be:</p>
    <ul>
      <li>A Accumulator: The Lower 8 Bits Of The Accumulator</li>
      <li>B Accumulator: The Upper 8 Bits Of The Accumulator</li>
      <li>C Accumulator: The 16-Bit Accumulator</li>
      <li><code>DBR</code>: the data bank register</li>
      <li>D Register: The 16-Bit Direct Register</li>
      <li>Dl Register: The Lower 8 Bits Of The Direct Register</li>
      <li>Dh Register: The Upper 8 Bits Of The Direct Register</li>
      <li>K Register: The Program Bank Register</li>
      <li>Pc: The 16-Bit Program Counter</li>
      <li><code>PCL</code>: the lower 8 bits of the program
      counter</li>
      <li><code>PCH</code>: the upper 8 bits of the program
      counter</li>
      <li>P Register: The Processor Status Register</li>
      <li>S Register: The 16-Bit Stack Pointer</li>
      <li>Sl Register: The Lower 8 Bits Of The Stack Pointer</li>
      <li>Sh Register: The Upper 8 Bits Of The Stack Pointer</li>
      <li>X Register: The 16-Bit X Index Register</li>
      <li>Xl Register: The Lower 8 Bits Of The X Index
      Register</li>
      <li>Xh Register: The Upper 8 Bits Of The X Index
      Register</li>
      <li>Y Register: The 16-Bit Y Index Register</li>
      <li>Yl Register: The Lower 8 Bits Of The Y Index
      Register</li>
      <li>Yh Register: The Upper 8 Bits Of The Y Index
      Register</li>
    </ul>
    <ul>
      <li>B Flag: The Break Flag</li>
      <li>C Flag: The Carry Flag</li>
      <li>D Flag: The Decimal Mode Flag</li>
      <li>E Flag: The Emulation Mode Flag</li>
      <li>I Flag: The Interrupt Disable Flag</li>
      <li>M Flag: The Accumulator and Memory Width Flag</li>
      <li>N Flag: The Negative Flag</li>
      <li>V Flag: The Overflow Flag</li>
      <li>X Flag: The Index Register Width Flag</li>
      <li>Z Flag: The Zero Flag</li>
    </ul>
    <p>The term "accumulator" without any additional qualifiers
    means the 16-bit accumulator (i.e. the C accumulator) when the
    m flag is 0, and the 8-bit accumulator (i.e. the A accumulator)
    when the m flag is 1. Furthermore, although "X register" and "Y
    register" refer to the 16-bit registers, when the x flag is 1,
    they are equivalent to the XL and YL registers, since the XH
    and YH register are forced to <code>$00</code> when the x flag
    is 1. (See below.) In effect, "X register" means the 16-bit
    register when the x flag is 0, and the 8-bit register (i.e. the
    XL register) when the x flag is 1. Likewise for "Y
    register".</p>
    <p>The P register contains 9 (yes, 9) of the flags.</p>
    <ul>
      <li>P Register Bit 7: N Flag</li>
      <li>P Register Bit 6: V Flag</li>
      <li>P Register Bit 5: M Flag (Native Mode)</li>
      <li>P Register Bit 4: X Flag (Native Mode), B Flag (Emulation
      Mode)</li>
      <li>P Register Bit 3: D Flag</li>
      <li>P Register Bit 2: I Flag</li>
      <li>P Register Bit 1: Z Flag</li>
      <li>P Register Bit 0: C Flag</li>
    </ul>
    <p>The e flag is separate from the P register but is accessed
    via the c flag using the <code>XCE</code> instruction (details
    below).</p>
    <p>How a particular instruction specifically affect the flags
    will be given in the description of that instruction below.
    Here is a general overview of the meaning of each flag. Note
    that for some instructions, the meaning of a flag (or flags)
    will be different than described in this brief overview. See
    the instruction description for the full details.</p>
    <p>The n flag is 1 when the result is negative; in other words,
    when the high bit (bit 7 for an 8-bit result, bit 15 for a
    16-bit result) is 1. The n flag is 0 when the result is
    non-negative (zero or positive), i.e. when the high bit of the
    result is 0.</p>
    <p>The v flag is 1 when an arithmetic overflow occurs. The v
    flag is 0 if there was no arithmetic overflow.</p>
    <p>When the m flag is 0, the accumulator (and memory) width is
    16 bits. When the m flag is 1, the accumulator (and memory)
    width is 8 bits. One way to remember what's what is that the
    even flag value (i.e. 0) is the width that is an even number of
    bytes (i.e. 2), and the odd flag value is an odd number of
    bytes.</p>
    <p>Likewise, when the x flag is 0, the index register width is
    16 bits. When the x flag is 1, the index register width is 8
    bits. Again, the even flag value is an even number of bytes and
    the odd flag value is an odd number of bytes. One important
    difference from the m flag is that when the x flag is 1 (8-bit
    index registers), the XH register and the YH register are both
    forced to <code>$00</code>. This means that after:</p>
    <pre>
CLC
XCE        ; native mode
REP #$10   ; 16-bit index registers
LDX #$1234
LDY #$5678
SEP #$10   ; 8-bit index registers
REP #$10   ; 16-bit index registers
</pre>
    <p class="added">the X register will be <code>$0034</code> and
    the Y register will be <code>$0078</code>. Thus, a subroutine
    that saves the X register and/or the Y register should do so
    BEFORE setting the x flag to 1. (As noted above, this is not
    the case for the m flag. The B accumulator is not forced to
    zero when the m flag is 1.) Attempting to change the value of
    the XH register or the YH register when the x flag is 1 will
    have no effect on XH or YH.</p>
    <p>On the 65C02 and NMOS 6502, the b flag is used for
    distinguishing an <code>IRQ</code> (hardware) interrupt from a
    <code>BRK</code> (software) interrupt. On the 65C816, in
    emulation mode, it is still used for this purpose. In native
    mode, there are separate vectors for <code>BRK</code> and
    <code>IRQ</code>, so the b flag is not necessary.</p>
    <p>When the d flag is 0, the <code>ADC</code> and
    <code>SBC</code> instructions perform binary arithmetic. When
    the d flag is 1, the <code>ADC</code> and <code>SBC</code>
    instructions perform <code>BCD</code> arithmetic.</p>
    <p>When the i flag is 0, (<code>IRQ</code>) interrupts are
    enabled. When the i flag is 1, (<code>IRQ</code>) interrupts
    are disabled. Note that <code>IRQ</code> is in fact the only
    interrupt that can be disabled by the i flag.</p>
    <ul>
      <li>The Z Flag Is 1 When The Result Is Zero. The Z Flag Is 0
      When The Result Is Non-Zero.</li>
    </ul>
    <ul>
      <li>The C Flag Is 1 When There Is An Arithmetic Carry (Carry
      Has The Same Meaning That "Carrying The One" Meant When You
      Learned Addition In School). The C Flag Is 0 When Where Was
      Not An Arithmetic Carry.</li>
    </ul>
    <p>When the e flag is 0, the 65C816 is in native mode. When the
    e flag is 1, the 65C816 is in emulation mode. When the e flag
    is 1, the SH register is forced to <code>$01</code>, the m flag
    is forced to 1, and the x flag is forced to 1. As a consequence
    of the x flag being forced to 1, the XH register and the YH
    register are forced to <code>$00</code> (see above). This means
    that after:</p>
    <pre>
CLC
XCE        ; native mode
REP #$30   ; 16-bit accumulator/memory and 16-bit index registers
LDX #$1234
LDY #$5678
LDA #$ABCD
TCS        ; set S register to $ABCD
SEC
XCE        ; emulation mode
CLC
XCE        ; native mode
</pre>
    <p class="added">the S register will be <code>$01CD</code>, the
    X register will be <code>$0034</code>, the Y register will be
    <code>$0078</code>, and m flag will be 1, and the x flag will
    be 1. The fact that the SH register gets forced to
    <code>$01</code> is especially important if native mode code is
    calling emulation mode code. Attempting to change the value of
    the SH register, the XH register, the YH register, the m flag,
    or the x flag when the e flag is 1 will have no effect.</p>
    <p>Register usage will be given when the addressing modes and
    the instructions are discussed. However, the Program Counter
    (PC) deserves mention here.</p>
    <p>Note that although the 65C816 has a 24-bit address space,
    the Program Counter is only a 16-bit register and the Program
    Bank Register is a separate (8-bit) register. This means that
    instruction execution wraps at bank boundaries. This is true
    even if the bank boundary occurs in the middle of the
    instruction.</p>
    <p>For example, if an <code>INX</code> instruction at
    <code>$12FFFF</code> is executed, the next instruction to be
    executed will be at instruction at <code>$120000</code> rather
    than <code>$130000</code>.</p>
    <p>Likewise, if the memory contents are as follows:</p>
    <ul>
      <li><code>$120000</code> Contains <code>$20</code></li>
      <li><code>$12Ffff</code> Contains <code>$C2</code> (A Rep
      Instruction)</li>
      <li><code>$130000</code> Contains <code>$30</code></li>
    </ul>
    <p class="added">then the second byte of the <code>REP</code>
    instruction at <code>$12FFFF</code> is <code>$20</code> (at
    <code>$120000</code>) rather than <code>$30</code> (at
    <code>$130000</code>); the next instruction to be executed will
    be at <code>$120001</code>, of course.</p>
    <p>It's also worth noting that branches (both forward and
    backward) wrap at bank boundaries as well. A <code>BCC</code>
    <code>$FFE0</code> instruction at <code>$130020</code> will
    branch to <code>$13FFC0</code> rather than
    <code>$12FFC0</code>. Likewise, a <code>BRL</code>
    <code>$2000</code> at <code>$13E000</code> will branch to
    <code>$132000</code> rather than <code>$142000</code>.</p>
  </section>
  <section>
    <h3><a id="5" name="5">5 Addressing Modes</a></h3>
    <p>The official names of the addressing modes of the 65C816 can
    be confusing and include the seemingly paradoxical Direct
    Indirect, Direct Indexed Indirect, and Direct Indirect Indexed.
    (In fact, the latter two addressing modes use different index
    registers, even though their names do not suggest this.) For
    this reason, in the interests of clarity, this document will
    use addressing mode names that more closely correspond with the
    typical assembler operand syntax. Terms such as direct,
    absolute, long, and relative will be use to distinguish operand
    width and whether the (object) code generated is the address
    itself or whether it is relative to the value of the Program
    Counter.</p>
  </section>
  <section>
    <h3><a id="5.1" name="5.1">5.1 Page and Bank Boundary
    Wrapping</a></h3>
    <p>Although each addressing mode will be described in detail
    below, there are a few rules of thumb that you can use to
    derive whether page and/or bank boundaries are crossed or
    not.</p>
  </section>
  <section>
    <h3><a id="5.1.1" name="5.1.1">5.1.1 Page Boundary
    Wrapping</a></h3>
    <p>Page boundary wrapping only occurs in emulation mode, and
    only for "old" instructions and addressing modes, i.e.
    instructions and addressing modes that are available on the
    65C02. Page boundary wrapping only occurs in the following
    situations:</p>
    <ul>
      <li>A. When The Dl Register Is <code>$00</code> (and In
      Emulation Mode -- Both Conditions Must Be Met), The Direct
      Page Wraps At A Page Boundary</li>
      <li>B. In Emulation Mode, The Stack Wraps At The Page 1
      Boundary</li>
    </ul>
    <p>An example of case A is when the D register is
    <code>$0000</code> (and thus DL is <code>$00</code>), the X
    register is <code>$0001</code>, and the e flag is 1 (i.e.
    emulation mode); in that case the memory location read by
    <code>LDA</code> <code>$FF</code>,X is <code>$000000</code>
    rather than <code>$000100</code>.</p>
    <p>An example of case B is when the S register is
    <code>$01FF</code> and the e flag is 1; in that case, a
    <code>PLA</code> reads (i.e. pulls) from memory location
    <code>$000100</code> rather than <code>$000200</code>.</p>
    <p>Note that because stack,S addressing is a "new" addressing
    mode (i.e. this addressing mode was not available on the
    65C02), it does not wrap at a bank boundary under any
    circumstances. Likewise, since <code>PEI</code> is a "new"
    instruction, <code>PEI</code> <code>$FF</code> does not wrap at
    a page boundary (either the direct page part, or the (pushing
    onto the) stack part).</p>
  </section>
  <section>
    <h3><a id="5.1.2" name="5.1.2">5.1.2 Bank Boundary
    Wrapping</a></h3>
    <p>Bank boundary wrapping occurs in both native and emulation
    mode (and does not depend on which mode the 65C816 is in). The
    following are confined to bank 0 ("confined to" means they
    address bank 0 and wrap at the bank 0 boundary):</p>
    <ul>
      <li>A. The Direct Page</li>
      <li>B. The Stack</li>
      <li>C. [Absolute] and (Absolute) Addressing Modes (Jmp Is The
      Only Instruction Available For Either Addressing Mode)</li>
    </ul>
    <p class="added">The following are confined to bank K:</p>
    <ul>
      <li>A. (Absolute,X) Addressing Mode (Jmp and Jsr Are The Only
      Instructions Available For This Addressing Mode)</li>
      <li>B. The Program Counter (I.E. The Pc Register); Again,
      This Means Branches Wrap At The Bank K Boundary</li>
    </ul>
    <p class="added">source,destination addressing (i.e. the
    <code>MVN</code> and <code>MVP</code> instructions) wraps at
    both the source and destination bank boundaries.</p>
    <p>Otherwise, wrapping does not occur at bank boundaries.</p>
  </section>
  <section>
    <h3><a id="5.1.3" name="5.1.3">5.1.3 Notation</a></h3>
    <p>To help illustrate when and if page and bank boundary
    wrapping occurs, a special notation is used in the diagrams
    below to indicate when, for example, adding an index register
    to an address should be considered a 24-bit calculation, when
    it should be truncated at 16 bits, and when it should be
    truncated at 8 bits.</p>
    <p>A 24-bit calculation is represented by a "triple wide"
    box:</p>
    <address>
      <address-bytes>
        <address-byte length="3">$HHMMLL+X</address-byte>
      </address-bytes>
      <address-description></address-description>
    </address>
    <p>If $HHMMLL is <code>$00FFEE</code> and X is
    <code>$44</code>, then the address is <code>$01</code> (high
    byte), <code>$00</code> (middle byte), <code>$32</code> (low
    byte).</p>
    <p>A calculation that is truncated at 16 bits is represented by
    a "double wide" box:</p>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">$LL+S</address-byte>
      </address-bytes>
      <address-description></address-description>
    </address>
    <p>If S is <code>$FFEE</code> and $LL is <code>$44</code>, then
    the address is <code>$00</code> (high byte), <code>$00</code>
    (middle byte), <code>$32</code> (low byte).</p>
    <p>A calculation that is truncated at 8 bits is represented by
    a "single wide" box:</p>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="1">DH</address-byte>
        <address-byte length="1">$LL+X</address-byte>
      </address-bytes>
      <address-description></address-description>
    </address>
    <p>If DH is <code>$FF</code>, $LL is <code>$EE</code>, and X is
    <code>$44</code> then the address is <code>$00</code> (high
    byte), <code>$FF</code> (middle byte), <code>$32</code> (low
    byte).</p>
    <p>Note that all addressing mode formulas in this document use
    unsigned arithmetic. (Yes, relative displacements are actually
    signed, but that will be covered later in the section dealing
    with relative addressing.)</p>
    <p>Each calculation is labelled with the address being
    represented. For example:</p>
    <address>
      <address-bytes>
        <address-byte length="3">$HHMMLL+X</address-byte>
      </address-bytes>
      <address-description>data lo</address-description>
    </address>
    <p class="added">shows the formula for the address of the low
    byte of the data (in this case, for long,X addressing).</p>
    <ul>
      <li>24-Bit Quantities Have High, Middle, and Low Bytes.</li>
      <li>16-Bit Quantities Have Only High and Low Bytes.</li>
      <li>8-Bit Quantities Have Only Low Bytes.</li>
    </ul>
    <p>For example, when the x flag is 1, then <code>LDX</code>
    loads only 8 bits of data, and the formula for the high byte
    would not apply in that instance.</p>
    <p>There are two addresses for indirect addressing modes: the
    address of the pointer, and the address of the data. For
    example, if the D register is <code>$0000</code>, then the
    address of the pointer of <code>LDA ($12)</code> is
    <code>$000012</code>. If the <code>DBR</code> is
    <code>$AB</code>, and:</p>
    <ul>
      <li><code>$000012</code> Contains <code>$Ef</code></li>
      <li><code>$000013</code> Contains <code>$Cd</code></li>
    </ul>
    <p class="added">then the address of the (low byte of the) data
    is <code>$ABCDEF</code>. So, for example:</p>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">D+$LL</address-byte>
      </address-bytes>
      <address-description>pointer lo</address-description>
    </address>
    <p class="added">shows the formula for the address of the low
    byte of the pointer. In addition, the following quantities are
    used in the formulas:</p>
    <ul>
      <li>$Ll = The Low Byte Of The Pointer (I.E. The Byte At
      Address "Pointer Lo")</li>
      <li>$Mm = The Middle Byte Of The Pointer (I.E. The Byte At
      Address "Pointer Mid")</li>
      <li>$Hh = The High Byte Of The Pointer (I.E. The Byte At
      Address "Pointer Hi")</li>
      <li>$Rr = The (Value Of The) Dbr</li>
    </ul>
    <p>In the previous <code>LDA ($12)</code> example, $ll would be
    <code>$EF</code> (the value of the low byte of the pointer). D,
    DH, K, X, and Y are, as you might expect, the value of the D,
    DH, K, X, and Y registers respectively. $OP is not used in the
    formulas, but simply indicates the opcode byte. For example,
    the bytes of an instruction with absolute addressing are $OP
    $LL $HH. This simply means that the instruction has three
    bytes: an opcode, a operand low byte, and an operand high
    byte.</p>
    <p>Note that $rrHHLL is a 24-bit value whose high byte is $rr,
    whose middle byte is $HH, and whose low byte is $LL. This is
    analogous to <code>$223344</code> whose high, middle, and low
    bytes are <code>$22</code>, <code>$33</code>, and
    <code>$44</code>. This allows 16-bit and 24-bit quantities to
    be easily composed from 8-bit quantities and makes the formulas
    much more succinct than they would be if ($HH &lt;&lt; 8) | $LL
    or 256 * $HH + $LL were used.</p>
    <p>Although a lowercase l can be confused with a 1, you should
    not confuse $ll (double lowercase L) in the formulas with
    <code>$11</code> (a pair of ones, i.e. 17 in decimal), since
    <code>$11</code> is not used anywhere in any of the formulas.
    Likewise, $rr was chosen for the value of the <code>DBR</code>
    rather than the seemingly more natural <code>$bb</code>, to
    avoid any confusion with the hexadecimal value <code>$BB</code>
    (i.e. 187 in decimal).</p>
    <p>However, case does matter; for example, $HH and $hh are
    different quantities. (Author's note: this notation is an
    imperfect solution; it seemed like composing $hhll from $hh and
    $ll made the formulas more readable than composing $hilo from
    $hi and $lo or composing $phpl from $ph (pointer hi) and
    $pl.)</p>
  </section>
  <section>
    <h3><a id="5.2" name="5.2">5.2 Absolute</a></h3>
    <p>Length: 3 bytes, $OP $LL $HH</p>
    <p>For <code>JMP</code> and <code>JSR</code>, the jump
    destination address is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">K</address-byte>
        <address-byte length="2">$HHLL</address-byte>
      </address-bytes>
      <address-description>destination</address-description>
    </address>
    <p class="added">For all other instructions, the address of the
    data is:</p>
    <address>
      <address-bytes>
        <address-byte length="3">$rrHHLL</address-byte>
      </address-bytes>
      <address-description>data lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="3">$rrHHLL+1</address-byte>
      </address-bytes>
      <address-description>data hi</address-description>
    </address>
    <p>Example 1: If the K register is <code>$12</code>, then
    <code>JMP</code> <code>$FFFF</code> jumps to
    <code>$12FFFF</code></p>
    <p>Example 2: If the <code>DBR</code> is <code>$12</code> and
    the m flag is 0, then <code>LDA</code> <code>$FFFF</code> loads
    the low byte of the data from address <code>$12FFFF</code>, and
    the high byte from address <code>$130000</code></p>
  </section>
  <section>
    <h3><a id="5.3" name="5.3">5.3 Absolute,X and
    Absolute,Y</a></h3>
    <p>Length: 3 bytes, $OP $LL $HH</p>
    <p>For absolute,X addressing the address of the data is:</p>
    <address>
      <address-bytes>
        <address-byte length="3">$rrHHLL+X</address-byte>
      </address-bytes>
      <address-description>data lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="3">$rrHHLL+X+1</address-byte>
      </address-bytes>
      <address-description>data hi</address-description>
    </address>
    <p class="added">absolute,Y addressing is the same, with Y
    substituted for X; the address of the data is:</p>
    <address>
      <address-bytes>
        <address-byte length="3">$rrHHLL+Y</address-byte>
      </address-bytes>
      <address-description>data lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="3">$rrHHLL+Y+1</address-byte>
      </address-bytes>
      <address-description>data hi</address-description>
    </address>
    <p>Example: If the <code>DBR</code> is <code>$12</code>, the X
    register is <code>$000A</code>, and the m flag is 0, then
    <code>LDA</code> <code>$FFFE</code>,X loads the low byte of the
    data from address <code>$130008</code>, and the high byte from
    address <code>$130009</code></p>
    <p>Note that this is one of the rare instances where emulation
    mode has different behavior than the 65C02 or NMOS 6502. Since
    the 65C02 and NMOS 6502 have a 16-bit address space, when the X
    register is <code>$80</code>, an <code>LDA</code>
    <code>$FFC0</code>,X instruction (for example) loads from
    address <code>$0040</code>; however on the 65C816, it loads
    from address <code>$010040</code> (rather than address
    <code>$000040</code>). In practice, this is not a problem since
    65C02 and NMOS 6502 code would almost certainly use an
    <code>LDA</code> <code>$C0</code>,X instruction (rather than
    <code>LDA $FFC0,X)</code> because zero page addressing always
    wraps at the page boundary on a 65C02 and NMOS 6502 (i.e. when
    the X register is <code>$80</code>, <code>LDA</code>
    <code>$C0</code>,X loads from address <code>$40</code>).</p>
  </section>
  <section>
    <h3><a id="5.4" name="5.4">5.4 (Absolute) and
    [Absolute]</a></h3>
    <p>Length: 3 bytes, $OP $LL $HH</p>
    <p>(absolute) addressing uses a 16-bit pointer. The address of
    the pointer is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">$HHLL</address-byte>
      </address-bytes>
      <address-description>pointer lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">$HHLL+1</address-byte>
      </address-bytes>
      <address-description>pointer hi</address-description>
    </address>
    <p class="added"><code>JMP</code> is the only instruction that
    uses this addressing mode; the jump destination address is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">K</address-byte>
        <address-byte length="2">$hhll</address-byte>
      </address-bytes>
      <address-description>destination</address-description>
    </address>
    <p class="added">[absolute] addressing is similar, but it uses
    a 24-bit pointer instead. The address of the pointer is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">$HHLL</address-byte>
      </address-bytes>
      <address-description>pointer lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">$HHLL+1</address-byte>
      </address-bytes>
      <address-description>pointer mid</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">$HHLL+2</address-byte>
      </address-bytes>
      <address-description>pointer hi</address-description>
    </address>
    <p>Likewise, <code>JMP</code> is the only instruction that uses
    this addressing mode; the jump destination address is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">$hh</address-byte>
        <address-byte length="2">$mmll</address-byte>
      </address-bytes>
      <address-description>destination</address-description>
    </address>
    <p>Example: If the K register is <code>$12</code> and</p>
    <ul>
      <li><code>$000000</code> Contains <code>$34</code></li>
      <li><code>$00Ffff</code> Contains <code>$56</code></li>
    </ul>
    <p class="added">then <code>JMP ($FFFF)</code> jumps to
    <code>$123456</code></p>
    <p>(Some assemblers allow the syntax <code>JML</code>
    (absolute) which is equivalent to <code>JMP</code> [absolute];
    however, the use of the latter syntax is more consistent with
    syntax of the [direct] and (direct) addressing modes, where
    parentheses indicate a 16-bit pointer and square brackets
    indicate a 24-bit pointer.)</p>
    <p>Note that on the 65C816, as on the 65C02, (absolute)
    addressing does not wrap at a page boundary, i.e. for a
    <code>JMP ($12FF)</code> the low byte of the destination
    address is taken from <code>$12FF</code> and the high byte of
    the destination address is taken from <code>$1300</code>. On
    the NMOS 6502, (absolute) addressing did wrap on a page
    boundary, which was unintentional (i.e. a bug); there, a
    <code>JMP ($12FF)</code> took the low byte of the destination
    address from <code>$12FF</code> but took the high byte of the
    destination address from <code>$1200</code> (rather than
    <code>$1300</code>).</p>
  </section>
  <section>
    <h3><a id="5.5" name="5.5">5.5 (Absolute,X)</a></h3>
    <p>Length: 3 bytes, $OP $LL $HH</p>
    <p>(absolute,X) addressing uses a 16-bit pointer. The address
    of the pointer is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">K</address-byte>
        <address-byte length="2">$HHLL+X</address-byte>
      </address-bytes>
      <address-description>pointer lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="1">K</address-byte>
        <address-byte length="2">$HHLL+X+1</address-byte>
      </address-bytes>
      <address-description>pointer hi</address-description>
    </address>
    <p class="added"><code>JMP</code> and <code>JSR</code> are the
    only instructions that use this addressing mode; the jump
    destination address is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">K</address-byte>
        <address-byte length="2">$hhll</address-byte>
      </address-bytes>
      <address-description>destination</address-description>
    </address>
    <p>Example: If the K register is <code>$12</code>, the X
    register is <code>$000A</code>, and</p>
    <ul>
      <li><code>$120008</code> Contains <code>$56</code></li>
      <li><code>$120009</code> Contains <code>$34</code></li>
    </ul>
    <p class="added">then <code>JMP ($FFFE,X)</code> jumps to
    <code>$123456</code></p>
  </section>
  <section>
    <h3><a id="5.6" name="5.6">5.6 Accumulator</a></h3>
    <p>Length: 1 byte, $OP</p>
    <p>The accumulator addressing mode is used by the instructions
    <code>ASL</code>, <code>DEC</code>, <code>INC</code>,
    <code>LSR</code>, <code>ROL</code>, and <code>ROR</code> when
    the operand is the accumulator rather than a memory location.
    (The distinction between this addressing mode and implied
    addressing is that the six instructions with this addressing
    mode have multiple addressing modes, but the instructions with
    implied addressing have only one addressing mode.) Different
    assemblers allow or require slightly different syntaxes. For
    example:</p>
    <pre>
ASL
ASLA
ASL A
</pre>
    <p class="added">are all equivalent, but an assembler may
    require or permit any of these syntaxes. (For this reason, many
    6502 family assemblers reserve the one letter label A, and do
    not allow it to be used in source code.)</p>
  </section>
  <section>
    <h3><a id="5.7" name="5.7">5.7 Direct</a></h3>
    <p>Length: 2 bytes, $OP $LL</p>
    <p>For "old" instructions (<code>PEI</code> is the only "new"
    instruction for this addressing mode), when the e flag is 1 and
    the DL register is <code>$00</code> (all three conditions --
    the instruction, the e flag, and the DL register -- must be
    met), the address of the data is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="1">DH</address-byte>
        <address-byte length="1">$LL</address-byte>
      </address-bytes>
      <address-description>data lo</address-description>
    </address>
    <p class="added">Otherwise, the address of the data is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">D+$LL</address-byte>
      </address-bytes>
      <address-description>data lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">D+$LL+1</address-byte>
      </address-bytes>
      <address-description>data hi</address-description>
    </address>
    <p>Example 1: If the D register is <code>$FF00</code> and the e
    flag is 1 (note that this means the m flag must be 1), then
    <code>LDA</code> <code>$FF</code> loads the low byte of the
    data from address <code>$00FFFF</code></p>
    <p>Example 2: If the D register is <code>$FF00</code> and the m
    flag is 0 (note that this means the e flag must be 0), then
    <code>LDA</code> <code>$FF</code> loads the low byte of the
    data from address <code>$00FFFF</code>, and the high byte from
    address <code>$000000</code></p>
  </section>
  <section>
    <h3><a id="5.8" name="5.8">5.8 Direct,X and Direct,Y</a></h3>
    <p>Length: 2 bytes, $OP $LL</p>
    <p>For direct,X addressing, when the e flag is 1 and the DL
    register is <code>$00</code> (both conditions must be met), the
    address of the data is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="1">DH</address-byte>
        <address-byte length="1">$LL+X</address-byte>
      </address-bytes>
      <address-description>data lo</address-description>
    </address>
    <p class="added">Otherwise, for direct,X addressing, the
    address of the data is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">D+$LL+X</address-byte>
      </address-bytes>
      <address-description>data lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">D+$LL+X+1</address-byte>
      </address-bytes>
      <address-description>data hi</address-description>
    </address>
    <p class="added">direct,Y addressing is the same, with Y
    substituted for X; when the e flag is 1 and the DL register is
    <code>$00</code> (both conditions must be met), the address of
    the data is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="1">DH</address-byte>
        <address-byte length="1">$LL+Y</address-byte>
      </address-bytes>
      <address-description>data lo</address-description>
    </address>
    <p class="added">Otherwise, for direct,Y addressing, the
    address of the data is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">D+$LL+Y</address-byte>
      </address-bytes>
      <address-description>data lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">D+$LL+Y+1</address-byte>
      </address-bytes>
      <address-description>data hi</address-description>
    </address>
    <p>Example 1: If the D register is <code>$FF00</code>, the X
    register is <code>$000A</code>, and the e flag is 1 (note that
    this means the m flag must be 1), then <code>LDA</code>
    <code>$FE</code>,X loads the low byte of the data from address
    <code>$00FF08</code></p>
    <p>Example 2: If the D register is <code>$FF00</code>, the X
    register is <code>$000A</code>, and the m flag is 0 (note that
    this means the e flag must be 0), then <code>LDA</code>
    <code>$FE</code>,X loads the low byte of the data from address
    <code>$000008</code>, and the high byte from address
    <code>$000009</code></p>
  </section>
  <section>
    <h3><a id="5.9" name="5.9">5.9 (Direct)</a></h3>
    <p>Length: 2 bytes, $OP $LL</p>
    <p>(direct) addressing uses a 16-bit pointer. When the e flag
    is 1 and the DL register is <code>$00</code> (both conditions
    must be met), the address of the pointer is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="1">DH</address-byte>
        <address-byte length="1">$LL</address-byte>
      </address-bytes>
      <address-description>pointer lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="1">DH</address-byte>
        <address-byte length="1">$LL+1</address-byte>
      </address-bytes>
      <address-description>pointer hi</address-description>
    </address>
    <p class="added">Otherwise, the address of the pointer is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">D+$LL</address-byte>
      </address-bytes>
      <address-description>pointer lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">D+$LL+1</address-byte>
      </address-bytes>
      <address-description>pointer hi</address-description>
    </address>
    <p>Unlike the address of the pointer, the address of the data
    does not depend on the value of the e flag, or the value of the
    DL register (or any other conditions, for that matter). The
    address of the data is always:</p>
    <address>
      <address-bytes>
        <address-byte length="3">$rrhhll</address-byte>
      </address-bytes>
      <address-description>data lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="3">$rrhhll+1</address-byte>
      </address-bytes>
      <address-description>data hi</address-description>
    </address>
    <p>Note that this means that the address of the pointer wraps
    at a bank boundary, but the address of the data does not.</p>
    <p>Example 1: if the D register is <code>$FF00</code> and the e
    flag is 1 (note this means the m flag must be 1), then for
    <code>LDA ($FF)</code>, the address of the low byte of the
    pointer is <code>$00FFFF</code> and the address of the high
    byte is <code>$00FF00</code>. Furthermore, if the
    <code>DBR</code> is <code>$12</code> and</p>
    <ul>
      <li><code>$00Ff00</code> Contains <code>$Ff</code></li>
      <li><code>$00Ffff</code> Contains <code>$Ff</code></li>
    </ul>
    <p class="added">then <code>LDA ($FF)</code> loads the low byte
    of the data from address <code>$12FFFF</code>.</p>
    <p>Example 2: if the D register is <code>$FF00</code> and the m
    flag is 0 (note this means the e flag must be 0), then for
    <code>LDA ($FF)</code>, the address of the low byte of the
    pointer is <code>$00FFFF</code> and the address of the high
    byte is <code>$000000</code>. Furthermore, if the
    <code>DBR</code> is <code>$12</code> and</p>
    <ul>
      <li><code>$000000</code> Contains <code>$Ff</code></li>
      <li><code>$00Ffff</code> Contains <code>$Ff</code></li>
    </ul>
    <p class="added">then <code>LDA ($FF)</code> loads the low byte
    of the data from address <code>$12FFFF</code>, and the high
    byte from <code>$130000</code>.</p>
  </section>
  <section>
    <h3><a id="5.10" name="5.10">5.10 [Direct]</a></h3>
    <p>Length: 2 bytes, $OP $LL</p>
    <p>[direct] addressing uses a 24-bit pointer. The address of
    the pointer is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">D+$LL</address-byte>
      </address-bytes>
      <address-description>pointer lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">D+$LL+1</address-byte>
      </address-bytes>
      <address-description>pointer mid</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">D+$LL+2</address-byte>
      </address-bytes>
      <address-description>pointer hi</address-description>
    </address>
    <p class="added">The address of the data is:</p>
    <address>
      <address-bytes>
        <address-byte length="3">$hhmmll</address-byte>
      </address-bytes>
      <address-description>data lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="3">$hhmmll+1</address-byte>
      </address-bytes>
      <address-description>data hi</address-description>
    </address>
    <p>Again, this means that the address of the pointer wraps at a
    bank boundary, but the address of the data does not.</p>
    <p>Example: if the D register is <code>$FF00</code> and the m
    flag is 0, then for <code>LDA [$FE]</code>, the address of the
    low byte of the pointer is <code>$00FFFE</code>, the address of
    the middle byte is <code>$00FFFF</code>, and the address of the
    high byte is <code>$000000</code>. Furthermore, if</p>
    <ul>
      <li><code>$000000</code> Contains <code>$12</code></li>
      <li><code>$00Fffe</code> Contains <code>$Ff</code></li>
      <li><code>$00Ffff</code> Contains <code>$Ff</code></li>
    </ul>
    <p class="added">then <code>LDA [$FE]</code> loads the low byte
    of the data from address <code>$12FFFF</code>, and the high
    byte from <code>$130000</code>.</p>
  </section>
  <section>
    <h3><a id="5.11" name="5.11">5.11 (Direct,X)</a></h3>
    <p>Length: 2 bytes, $OP $LL</p>
    <p>(direct,X) addressing uses a 16-bit pointer. When the e flag
    is 1 and the DL register is <code>$00</code> (both conditions
    must be met), the address of the pointer is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="1">DH</address-byte>
        <address-byte length="1">$LL+X</address-byte>
      </address-bytes>
      <address-description>pointer lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="1">DH</address-byte>
        <address-byte length="1">$LL+X+1</address-byte>
      </address-bytes>
      <address-description>pointer hi</address-description>
    </address>
    <p class="added">Otherwise, the address of the pointer is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">D+$LL+X</address-byte>
      </address-bytes>
      <address-description>pointer lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">D+$LL+X+1</address-byte>
      </address-bytes>
      <address-description>pointer hi</address-description>
    </address>
    <p>Again, unlike the address of the pointer, the address of the
    data does not depend on the value of the e flag, or the value
    of the DL register (or any other conditions, for that matter).
    The address of the data is always:</p>
    <address>
      <address-bytes>
        <address-byte length="3">$rrhhll</address-byte>
      </address-bytes>
      <address-description>data lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="3">$rrhhll+1</address-byte>
      </address-bytes>
      <address-description>data hi</address-description>
    </address>
    <p>Again, this means that the address of the pointer wraps at a
    bank boundary, but the address of the data does not.</p>
    <p>Example 1: if the D register is <code>$FF00</code>, the X
    register is <code>$000A</code>, and the e flag is 1 (note that
    this means the m flag must be 1), then for <code>LDA
    ($FE,X)</code>, the address of the low byte of the pointer is
    <code>$00FF08</code> and the address of the high byte is
    <code>$00FF09</code>. Furthermore, if the <code>DBR</code> is
    <code>$12</code> and</p>
    <ul>
      <li><code>$00Ff08</code> Contains <code>$Ff</code></li>
      <li><code>$00Ff09</code> Contains <code>$Ff</code></li>
    </ul>
    <p class="added">then <code>LDA ($FE,X)</code> loads the low
    byte of the data from address <code>$12FFFF</code>.</p>
    <p>Example 2: if the D register is <code>$FF00</code>, the X
    register is <code>$000A</code>, and the m flag is 0 (note that
    this means the e flag must be 0), then for <code>LDA
    ($FE,X)</code>, the address of the low byte of the pointer is
    <code>$000008</code> and the address of the high byte is
    <code>$000009</code>. Furthermore, if the <code>DBR</code> is
    <code>$12</code> and</p>
    <ul>
      <li><code>$000008</code> Contains <code>$Ff</code></li>
      <li><code>$000009</code> Contains <code>$Ff</code></li>
    </ul>
    <p class="added">then <code>LDA ($FE,X)</code> loads the low
    byte of the data from address <code>$12FFFF</code>, and the
    high byte from <code>$130000</code>.</p>
  </section>
  <section>
    <h3><a id="5.12" name="5.12">5.12 (Direct),Y</a></h3>
    <p>Length: 2 bytes, $OP $LL</p>
    <p>(direct),Y addressing uses a 16-bit pointer. When the e flag
    is 1 and the DL register is <code>$00</code> (both conditions
    must be met), the address of the pointer is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="1">DH</address-byte>
        <address-byte length="1">$LL</address-byte>
      </address-bytes>
      <address-description>pointer lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="1">DH</address-byte>
        <address-byte length="1">$LL+1</address-byte>
      </address-bytes>
      <address-description>pointer hi</address-description>
    </address>
    <p class="added">Otherwise, the address of the pointer is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">D+$LL</address-byte>
      </address-bytes>
      <address-description>pointer lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">D+$LL+1</address-byte>
      </address-bytes>
      <address-description>pointer hi</address-description>
    </address>
    <p>Again, unlike the address of the pointer, the address of the
    data does not depend on the value of the e flag, or the value
    of the DL register (or any other conditions, for that matter).
    The address of the data is always:</p>
    <address>
      <address-bytes>
        <address-byte length="3">$rrhhll+Y</address-byte>
      </address-bytes>
      <address-description>data lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="3">$rrhhll+Y+1</address-byte>
      </address-bytes>
      <address-description>data hi</address-description>
    </address>
    <p>Again, this means that the address of the pointer wraps at a
    bank boundary, but the address of the data does not.</p>
    <p>Again, note that this is one of the rare instances where
    emulation mode has different behavior than the 65C02 or NMOS
    6502. Since the 65C02 and NMOS 6502 have a 16-bit address
    space, if the address of the data were <code>$FFFE</code>+Y and
    the Y register were <code>$0A</code>, the address of the data
    would be <code>$0008</code>. On the 65C816, the address of the
    data would be <code>$010008</code> (assuming the
    <code>DBR</code> was <code>$00</code>). In practice, this is
    typically not a problem, since code written for the 65C02 or
    NMOS 6502 would almost never use a pointer that would wrap at
    the 16-bit address space boundary like that.</p>
    <p>Example 1: if the D register is <code>$FF00</code> and the e
    flag is 1 (note that this means the m flag must be 1), then for
    <code>LDA ($FF),Y</code>, the address of the low byte of the
    pointer is <code>$00FFFF</code> and the address of the high
    byte is <code>$00FF00</code>. Furthermore, if the
    <code>DBR</code> is <code>$12</code>, the Y register is
    <code>$000A</code>, and</p>
    <ul>
      <li><code>$00Ff00</code> Contains <code>$Ff</code></li>
      <li><code>$00Ffff</code> Contains <code>$Fe</code></li>
    </ul>
    <p class="added">then <code>LDA ($FF),Y</code> loads the low
    byte of the data from address <code>$130008</code>.</p>
    <p>Example 2: if the D register is <code>$FF00</code> and the m
    flag is 0 (note that this means the e flag must be 0), then for
    <code>LDA ($FF),Y</code>, the address of the low byte of the
    pointer is <code>$00FFFF</code> and the address of the high
    byte is <code>$000000</code>. Furthermore, if the
    <code>DBR</code> is <code>$12</code>, the Y register is
    <code>$000A</code>, and</p>
    <ul>
      <li><code>$000000</code> Contains <code>$Ff</code></li>
      <li><code>$00Ffff</code> Contains <code>$Fe</code></li>
    </ul>
    <p class="added">then <code>LDA ($FF),Y</code> loads the low
    byte of the data from address <code>$130008</code>, and the
    high byte from <code>$130009</code>.</p>
  </section>
  <section>
    <h3><a id="5.13" name="5.13">5.13 [Direct],Y</a></h3>
    <p>Length: 2 bytes, $OP $LL</p>
    <p>[direct],Y addressing uses a 24-bit pointer. The address of
    the pointer is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">D+$LL</address-byte>
      </address-bytes>
      <address-description>pointer lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">D+$LL+1</address-byte>
      </address-bytes>
      <address-description>pointer mid</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">D+$LL+2</address-byte>
      </address-bytes>
      <address-description>pointer hi</address-description>
    </address>
    <p class="added">The address of the data is:</p>
    <address>
      <address-bytes>
        <address-byte length="3">$hhmmll+Y</address-byte>
      </address-bytes>
      <address-description>data lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="3">$hhmmll+Y+1</address-byte>
      </address-bytes>
      <address-description>data hi</address-description>
    </address>
    <p>Again, this means that the address of the pointer wraps at a
    bank boundary, but the address of the data does not.</p>
    <p>Example: if the D register is <code>$FF00</code> and the m
    flag is 0, then for <code>LDA [$FE],Y</code>, the address of
    the low byte of the pointer is <code>$00FFFE</code>, the
    address of the middle byte is <code>$00FFFF</code>, and the
    address of the high byte is <code>$000000</code>. Furthermore,
    if the Y register is <code>$000A</code>, and</p>
    <ul>
      <li><code>$000000</code> Contains <code>$12</code></li>
      <li><code>$00Fffe</code> Contains <code>$Fc</code></li>
      <li><code>$00Ffff</code> Contains <code>$Ff</code></li>
    </ul>
    <p class="added">then <code>LDA [$FE],Y</code> loads the low
    byte of the data from address <code>$130006</code>, and the
    high byte from <code>$130007</code>.</p>
  </section>
  <section>
    <h3><a id="5.14" name="5.14">5.14 Immediate</a></h3>
    <p>Length: 2 bytes, $OP $LL (for 8-bit data)</p>
    <p>Length: 3 bytes, $OP $LL $HH (for 16-bit data)</p>
    <p>$LL (or $HHLL for 16-bit data) is the data; thus, the
    address of the data is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">K</address-byte>
        <address-byte length="2">PC+1</address-byte>
      </address-bytes>
      <address-description>data lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="1">K</address-byte>
        <address-byte length="2">PC+2</address-byte>
      </address-bytes>
      <address-description>data hi</address-description>
    </address>
    <p>The width of the immediate data depends on the instruction.
    There are four cases.</p>
    <ul>
      <li>A. The Data Width Depends On The Value Of The M Flag
      (E.G. Lda)</li>
      <li>B. The Data Width Depends On The Value Of The X Flag
      (E.G. Ldx)</li>
      <li>C. The Data Is 8 Bits Wide (E.G. Rep)</li>
      <li>D. The Data Is 16 Bits Wide (E.G. Pea)</li>
    </ul>
    <p>Incidentally, <code>PER</code> is an unusual case. It can be
    considered 16-bit immediate data, like <code>PEA</code>. Unlike
    <code>PEA</code> (which pushes the immediate data onto the
    stack), <code>PER</code> adds the immediate data to the address
    of the next instruction. This is the same formula that
    relative16 addressing uses for the destination address, and
    thus <code>PER</code> is often documented as relative16
    addressing rather than immediate addressing. See the section on
    the <code>PER</code> instruction for further details.</p>
  </section>
  <section>
    <h3><a id="5.15" name="5.15">5.15 Implied</a></h3>
    <p>Length: 1 byte, $OP</p>
    <p>Instructions with implied addressing (e.g. <code>CLC</code>)
    have no operand. The name "implied" comes from the fact that
    the instruction itself implies which register, flag, or memory
    location will be used by the instruction.</p>
    <p>Note that even though all instructions with implied
    addressing have only one addressing mode, the converse is not
    true; not all instructions with only one addressing mode are
    implied addressing. For example. <code>BCC</code> and
    <code>JSL</code> each have only one addressing mode, yet are
    not implied addressing.</p>
  </section>
  <section>
    <h3><a id="5.16" name="5.16">5.16 Long</a></h3>
    <p>Length: 4 bytes, $OP $LL $MM $HH</p>
    <p>For <code>JMP</code>, the jump destination address is:</p>
    <address>
      <address-bytes>
        <address-byte length="3">$HHMMLL</address-byte>
      </address-bytes>
      <address-description>destination</address-description>
    </address>
    <p class="added">For all other instructions, the address of the
    data is:</p>
    <address>
      <address-bytes>
        <address-byte length="3">$HHMMLL</address-byte>
      </address-bytes>
      <address-description>data lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="3">$HHMMLL+1</address-byte>
      </address-bytes>
      <address-description>data hi</address-description>
    </address>
    <p>Example: If the m flag is 0, then <code>LDA</code>
    <code>$12FFFF</code> loads the low byte of the data from
    address <code>$12FFFF</code>, and the high byte from address
    <code>$130000</code>.</p>
  </section>
  <section>
    <h3><a id="5.17" name="5.17">5.17 Long,X</a></h3>
    <p>Length: 4 bytes, $OP $LL $MM $HH</p>
    <p>The address of the data is:</p>
    <address>
      <address-bytes>
        <address-byte length="3">$HHMMLL+X</address-byte>
      </address-bytes>
      <address-description>data lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="3">$HHMMLL+X+1</address-byte>
      </address-bytes>
      <address-description>data hi</address-description>
    </address>
    <p>Example: If the X register is <code>$000A</code> and the m
    flag is 0, then <code>LDA</code> <code>$12FFFE</code>,X loads
    the low byte of the data from address <code>$130008</code>, and
    the high byte from address <code>$130009</code>.</p>
  </section>
  <section>
    <h3><a id="5.18" name="5.18">5.18 Relative8 and
    Relative16</a></h3>
    <p>Length: 2 bytes, $OP $LL (for relative8 addressing)</p>
    <p>Length: 3 bytes, $OP $LL $HH (for relative16 addressing)</p>
    <p>For relative8 addressing, $LL is a signed 8-bit branch
    displacement, where <code>$00</code> to <code>$7F</code> is a
    branch distance of 0 to 127, and <code>$80</code> to
    <code>$FF</code> is a branch distance of -128 to -1. Note that
    PC is the address of $OP (i.e. the address of the relative8
    instruction), whereas the branch distance is actually the
    distance from the next instruction; hence the formula uses PC+2
    rather than PC. Treating the branch displacement as a signed
    number (this formula is also valid when treating the branch
    displacement as an unsigned number and <code>$00</code> &lt;=
    $LL &lt;= <code>$7F</code>, i.e. $LL ranges from 0 to 127), the
    branch destination address is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">K</address-byte>
        <address-byte length="2">PC+2+$LL</address-byte>
      </address-bytes>
      <address-description></address-description>
    </address>
    <p>When treating the branch displacement as unsigned number and
    <code>$80</code> &lt;= $LL &lt;= <code>$FF</code>, (i.e. $LL
    ranges from 128 to 255), the branch destination address is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">K</address-byte>
        <address-byte length="2">PC-254+$LL</address-byte>
      </address-bytes>
      <address-description></address-description>
    </address>
    <p class="added">relative16 addressing is similar, but with a
    16-bit branch displacement instead of an 8-bit displacement.
    Likewise, for relative16 addressing, the displacement is
    signed, but as it happens, you get the same result whether
    treat the displacement as signed or unsigned, so there is a
    single formula. <code>BRL</code> is the only instruction with
    this addressing mode (see the discussion of <code>PER</code> in
    the section on immediate addressing). The branch destination
    address is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">K</address-byte>
        <address-byte length="2">PC+3+$HHLL</address-byte>
      </address-bytes>
      <address-description></address-description>
    </address>
  </section>
  <section>
    <h3><a id="5.19" name="5.19">5.19 Source,Destination</a></h3>
    <p>Length: 3 bytes, $OP $TT $SS</p>
    <p>This is the addressing mode of the <code>MVN</code> and
    <code>MVP</code> instructions. The move source address is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">$SS</address-byte>
        <address-byte length="2">X</address-byte>
      </address-bytes>
      <address-description></address-description>
    </address>
    <p class="added">The move destination address is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">$TT</address-byte>
        <address-byte length="2">Y</address-byte>
      </address-bytes>
      <address-description></address-description>
    </address>
    <p>Example: If the accumulator is <code>$0002</code>, the X
    register is <code>$FFFE</code>, and the Y register is
    <code>$FFFF</code>, then <code>MVN</code>
    <code>#$12</code>,<code>#$34</code> moves</p>
    <ul>
      <li>The Data At <code>$12Fffe</code> To
      <code>$34Ffff</code></li>
      <li>The Data At <code>$12Ffff</code> To
      <code>$340000</code></li>
      <li>The Data At <code>$120000</code> To
      <code>$340001</code></li>
    </ul>
  </section>
  <section>
    <h3><a id="5.20" name="5.20">5.20 Stack,S</a></h3>
    <p>Length: 2 bytes, $OP $LL</p>
    <p>The address of the data is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">$LL+S</address-byte>
      </address-bytes>
      <address-description>data lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">$LL+S+1</address-byte>
      </address-bytes>
      <address-description>data hi</address-description>
    </address>
    <p>Example: If the S register is <code>$FF10</code> and the m
    flag is 0, then <code>LDA</code> <code>$FA</code>,S loads the
    low byte of the data from address <code>$00000A</code>, and the
    high byte from address <code>$00000B</code>.</p>
  </section>
  <section>
    <h3><a id="5.21" name="5.21">5.21 (Stack,S),Y</a></h3>
    <p>Length: 2 bytes, $OP $LL</p>
    <p>(stack,S),Y addressing uses a 16-bit pointer. The address of
    the pointer is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">$LL+S</address-byte>
      </address-bytes>
      <address-description>pointer lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">$LL+S+1</address-byte>
      </address-bytes>
      <address-description>pointer hi</address-description>
    </address>
    <p class="added">The address of the data is:</p>
    <address>
      <address-bytes>
        <address-byte length="3">$rrhhll+Y</address-byte>
      </address-bytes>
      <address-description>data lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="3">$rrhhll+Y+1</address-byte>
      </address-bytes>
      <address-description>data hi</address-description>
    </address>
    <p>Again, this means that the address of the pointer wraps at a
    bank boundary, but the address of the data does not.</p>
    <p>Example: if the S register is <code>$FF10</code> and the m
    flag is 0, then for <code>LDA ($FA,S),Y</code>, the address of
    the low byte of the pointer is <code>$00000A</code> and the
    address of the high byte is <code>$00000B</code>. Furthermore,
    if the <code>DBR</code> is <code>$12</code>, the Y register is
    <code>$0050</code>, and</p>
    <ul>
      <li><code>$00000A</code> Contains <code>$F0</code></li>
      <li><code>$00000B</code> Contains <code>$Ff</code></li>
    </ul>
    <p class="added">then <code>LDA ($FA,S),Y</code> loads the low
    byte of the data from address <code>$130040</code>, and the
    high byte from <code>$130041</code>.</p>
  </section>
  <section>
    <h3><a id="5.22" name="5.22">5.22 Page and Bank Boundary
    Wrapping Of The Stack</a></h3>
    <p>The previous sections covered the addressing of the
    instruction operands. However, some instructions push onto, and
    pull from, the stack. This section covers how the stack itself
    is addressed. It is not really an addressing mode, but it uses
    the same notation as the addressing modes did.</p>
    <p>Instructions can push or pull 8-bit (e.g. <code>PHK</code>
    and <code>PLP</code>), 16-bit (e.g. <code>JSR</code> and
    <code>PEA</code>), or 24-bit (e.g. <code>JSL</code>)
    quantities. It is important to keep in mind that in this
    section, software (e.g. <code>BRK</code>) and hardware (e.g.
    <code>NMI</code>) interrupts are treated as two separate
    pushes: the address (16 bits in emulation mode, 24 bits in
    native mode), and the P register (8 bits), rather than a single
    (24-bit or 32-bit) push. Likewise, <code>RTI</code> is treated
    as two separate pulls: the P register and the address.</p>
    <p>Note that in these formulas, S and SL refer to values of the
    S and SL registers before the instruction was executed. After
    pushing N bytes:</p>
    <ul>
      <li>In Emulation Mode, Sl Will Be Decremented N Times</li>
      <li>In Native Mode, S Will Be Decremented N Times</li>
    </ul>
    <p class="added">Likewise, after pulling N bytes:</p>
    <ul>
      <li>In Emulation Mode, Sl Will Be Incremented N Times</li>
      <li>In Native Mode, S Will Be Incremented N Times</li>
    </ul>
    <p>For all interrupts and "old" instructions, when the e flag
    is 1, the address of the data for an 8-bit push is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="1">1</address-byte>
        <address-byte length="1">SL</address-byte>
      </address-bytes>
      <address-description>data lo</address-description>
    </address>
    <p class="added">Otherwise, the address of the data for an
    8-bit push is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">S</address-byte>
      </address-bytes>
      <address-description>data lo</address-description>
    </address>
    <p>For all interrupts and "old" instructions, when the e flag
    is 1, the address of the data for a 16-bit push is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="1">1</address-byte>
        <address-byte length="1">SL</address-byte>
      </address-bytes>
      <address-description>data hi</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="1">1</address-byte>
        <address-byte length="1">SL-1</address-byte>
      </address-bytes>
      <address-description>data lo</address-description>
    </address>
    <p class="added">Otherwise, the address of the data for a
    16-bit push is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">S</address-byte>
      </address-bytes>
      <address-description>data hi</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">S-1</address-byte>
      </address-bytes>
      <address-description>data lo</address-description>
    </address>
    <p class="added">The address of the data for a 24-bit push
    is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">S</address-byte>
      </address-bytes>
      <address-description>data hi</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">S-1</address-byte>
      </address-bytes>
      <address-description>data mid</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">S-2</address-byte>
      </address-bytes>
      <address-description>data lo</address-description>
    </address>
    <p>For all interrupts and "old" instructions, when the e flag
    is 1, the address of the data for a pull is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="1">1</address-byte>
        <address-byte length="1">SL+1</address-byte>
      </address-bytes>
      <address-description>data lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="1">1</address-byte>
        <address-byte length="1">SL+2</address-byte>
      </address-bytes>
      <address-description>data hi</address-description>
    </address>
    <p class="added">Otherwise, the address of the data for a pull
    is:</p>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">S+1</address-byte>
      </address-bytes>
      <address-description>data lo</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">S+2</address-byte>
      </address-bytes>
      <address-description>data mid</address-description>
    </address>
    <address>
      <address-bytes>
        <address-byte length="1">0</address-byte>
        <address-byte length="2">S+3</address-byte>
      </address-bytes>
      <address-description>data hi</address-description>
    </address>
  </section>
  <section>
    <h3><a id="5.23" name="5.23">5.23 A Note On Operand
    Addresses</a></h3>
    <p>On the 65C02 and NMOS 6502, <code>LDA</code>
    <code>$12</code> (direct addressing) and <code>LDA</code>
    <code>$0012</code> (absolute addressing) load data from the
    same address. On the 65C816, this is not always the case. For
    example, if the <code>DBR</code> is <code>$12</code>, the D
    register is <code>$3400</code>, and the m flag is 1, then</p>
    <pre>
LDA $56 (direct addressing) loads data from $003456
LDA $0056 (absolute addressing) loads data from $120056
LDA $000056 (long addressing) loads data from $000056
</pre>
    <p>When encountering an operand address whose high byte is
    <code>$00</code>, almost all 65C02 and NMOS 6502 assemblers
    will use zero page addressing rather than absolute addressing
    as an optimization, since this usually saves a byte and a
    cycle. It is rarely necessary to override this optimization
    (i.e. to tell the assembler to use absolute addressing).</p>
    <p>However, on the 65C816, it is necessary to pay much closer
    attention to the addressing mode being assembled, as the
    example above illustrates. An assembler that assembles code for
    the 65C816, as well as one (or both) of its 8-bit predecessors
    may perform the aforementioned optimization even for the
    65C816, which may be not what you wanted or intended. It may be
    worthwhile to review the documentation of your assembler to see
    how to explicitly specify whether direct, absolute, or long
    addressing will be used.</p>
  </section>
  <section>
    <h3><a id="6" name="6">6 Instructions</a></h3>
    <p class="added">The columns of the tables that describe the
    instructions are:</p>
    <pre>
OP - the opcode in hex
LEN - the length of the instruction in bytes
CYCLES - the number of cycles the instruction takes
MODE - the addressing mode of the instruction
nvmxdizc e - the flags affected by the instruction
SYNTAX - an example of the assembler syntax of the instruction
</pre>
    <p class="added">In the <code>LEN</code> column:</p>
    <ul>
      <li>M = M Flag</li>
      <li>X = X Flag</li>
    </ul>
    <p>Thus, for example, 3-m is a succinct way of saying 3 bytes
    when the m flag is 0, and 2 bytes when the m flag is 1.</p>
    <p>In the CYCLES column:</p>
    <ul>
      <li>E = E Flag</li>
      <li>M = M Flag</li>
      <li>P = 1 If A Page Boundary Is Crossed, 0 Otherwise</li>
      <li>T = 1 If Branch Taken, 0 Otherwise</li>
      <li>W = 0 If The Dl Register Is <code>$00</code>, 1
      Otherwise</li>
      <li>X = X Flag</li>
    </ul>
    <p>Again, for example, 3-m is a succinct way of saying 3 cycles
    when the m flag is 0, and 2 cycles when the m flag is 1.</p>
    <p>In the "nvmxdizc e" column:</p>
    <ul>
      <li>0 = Flag Is Cleared</li>
      <li>1 = Flag Is Set</li>
      <li>* = Flag Is Affected</li>
      <li>M = Flag Is Affected By The (16-8*M)-Bit Result</li>
      <li>X = Flag Is Affected By The (16-8*X)-Bit Result</li>
    </ul>
    <p>For example, the m in the z column of <code>ADC</code> means
    that the z flag is affected by the 16-bit result when the m
    flag is 0, and the 8-bit result when the m flag is 1.</p>
    <p>In general, in emulation mode (and for 8-bit results in
    native mode), the 65C816 has the same behavior as 65C02 but the
    same cycle counts as the NMOS 6502. For example, when the d
    flag is 1 and the m flag is 1, <code>ADC</code>
    <code>#$00</code> will have valid n, z, and c flag results
    (like the 65C02, but unlike the NMOS 6502), but will take 2
    cycles (like the NMOS 6502, but unlike the 65C02).</p>
    <p>Note that the cycle counts may look a little different than
    what you may be used to with the 65C02 or NMOS 6502, even when
    the cycle count is the same for 8-bit results. For example,
    <code>LDA</code> absolute is 4 cycles on the 65C02 and NMOS
    6502, but the formula here is 5-m cycles, which is 4 cycles for
    the 8-bit case (i.e. when the m flag is 1).</p>
  </section>
  <section>
    <h3><a id="6.1.1.1" name="6.1.1.1">6.1.1.1 <code>ADC</code>
    <code>SBC</code></a></h3>
    <pre>
ADd with Carry
SuBtract with Carry
</pre>
    <table class="opcode">
      <thead>
        <tr>
          <th>OP</th>
          <th>LEN</th>
          <th>CYCLES</th>
          <th>MODE</th>
          <th>nvmxdizc e</th>
          <th>SYNTAX</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>61</td>
          <td>2</td>
          <td>7-m+w</td>
          <td>(dir,X)</td>
          <td>mm....mm .</td>
          <td>ADC ($10,X)</td>
        </tr>
        <tr>
          <td>63</td>
          <td>2</td>
          <td>5-m</td>
          <td>stk,S</td>
          <td>mm....mm .</td>
          <td>ADC $32,S</td>
        </tr>
        <tr>
          <td>65</td>
          <td>2</td>
          <td>4-m+w</td>
          <td>dir</td>
          <td>mm....mm .</td>
          <td>ADC $10</td>
        </tr>
        <tr>
          <td>67</td>
          <td>2</td>
          <td>7-m+w</td>
          <td>[dir]</td>
          <td>mm....mm .</td>
          <td>ADC [$10]</td>
        </tr>
        <tr>
          <td>69</td>
          <td>3-m</td>
          <td>3-m</td>
          <td>imm</td>
          <td>mm....mm .</td>
          <td>ADC #$54</td>
        </tr>
        <tr>
          <td>6D</td>
          <td>3</td>
          <td>5-m</td>
          <td>abs</td>
          <td>mm....mm .</td>
          <td>ADC $9876</td>
        </tr>
        <tr>
          <td>6F</td>
          <td>4</td>
          <td>6-m</td>
          <td>long</td>
          <td>mm....mm .</td>
          <td>ADC $FEDBCA</td>
        </tr>
        <tr>
          <td>71</td>
          <td>2</td>
          <td>7-m+w-x+x*p</td>
          <td>(dir),Y</td>
          <td>mm....mm .</td>
          <td>ADC ($10),Y</td>
        </tr>
        <tr>
          <td>72</td>
          <td>2</td>
          <td>6-m+w</td>
          <td>(dir)</td>
          <td>mm....mm .</td>
          <td>ADC ($10)</td>
        </tr>
        <tr>
          <td>73</td>
          <td>2</td>
          <td>8-m</td>
          <td>(stk,S),Y</td>
          <td>mm....mm .</td>
          <td>ADC ($32,S),Y</td>
        </tr>
        <tr>
          <td>75</td>
          <td>2</td>
          <td>5-m+w</td>
          <td>dir,X</td>
          <td>mm....mm .</td>
          <td>ADC $10,X</td>
        </tr>
        <tr>
          <td>77</td>
          <td>2</td>
          <td>7-m+w</td>
          <td>[dir],Y</td>
          <td>mm....mm .</td>
          <td>ADC [$10],Y</td>
        </tr>
        <tr>
          <td>79</td>
          <td>3</td>
          <td>6-m-x+x*p</td>
          <td>abs,Y</td>
          <td>mm....mm .</td>
          <td>ADC $9876,Y</td>
        </tr>
        <tr>
          <td>7D</td>
          <td>3</td>
          <td>6-m-x+x*p</td>
          <td>abs,X</td>
          <td>mm....mm .</td>
          <td>ADC $9876,X</td>
        </tr>
        <tr>
          <td>7F</td>
          <td>4</td>
          <td>6-m</td>
          <td>long,X</td>
          <td>mm....mm .</td>
          <td>ADC $FEDCBA,X</td>
        </tr>
        <tr>
          <td>E1</td>
          <td>2</td>
          <td>7-m+w</td>
          <td>(dir,X)</td>
          <td>mm....mm .</td>
          <td>SBC ($10,X)</td>
        </tr>
        <tr>
          <td>E3</td>
          <td>2</td>
          <td>5-m</td>
          <td>stk,S</td>
          <td>mm....mm .</td>
          <td>SBC $32,S</td>
        </tr>
        <tr>
          <td>E5</td>
          <td>2</td>
          <td>4-m+w</td>
          <td>dir</td>
          <td>mm....mm .</td>
          <td>SBC $10</td>
        </tr>
        <tr>
          <td>E7</td>
          <td>2</td>
          <td>7-m+w</td>
          <td>[dir]</td>
          <td>mm....mm .</td>
          <td>SBC [$10]</td>
        </tr>
        <tr>
          <td>E9</td>
          <td>3-m</td>
          <td>3-m</td>
          <td>imm</td>
          <td>mm....mm .</td>
          <td>SBC #$54</td>
        </tr>
        <tr>
          <td>ED</td>
          <td>3</td>
          <td>5-m</td>
          <td>abs</td>
          <td>mm....mm .</td>
          <td>SBC $9876</td>
        </tr>
        <tr>
          <td>EF</td>
          <td>4</td>
          <td>6-m</td>
          <td>long</td>
          <td>mm....mm .</td>
          <td>SBC $FEDBCA</td>
        </tr>
        <tr>
          <td>F1</td>
          <td>2</td>
          <td>7-m+w-x+x*p</td>
          <td>(dir),Y</td>
          <td>mm....mm .</td>
          <td>SBC ($10),Y</td>
        </tr>
        <tr>
          <td>F2</td>
          <td>2</td>
          <td>6-m+w</td>
          <td>(dir)</td>
          <td>mm....mm .</td>
          <td>SBC ($10)</td>
        </tr>
        <tr>
          <td>F3</td>
          <td>2</td>
          <td>8-m</td>
          <td>(stk,S),Y</td>
          <td>mm....mm .</td>
          <td>SBC ($32,S),Y</td>
        </tr>
        <tr>
          <td>F5</td>
          <td>2</td>
          <td>5-m+w</td>
          <td>dir,X</td>
          <td>mm....mm .</td>
          <td>SBC $10,X</td>
        </tr>
        <tr>
          <td>F7</td>
          <td>2</td>
          <td>7-m+w</td>
          <td>[dir],Y</td>
          <td>mm....mm .</td>
          <td>SBC [$10],Y</td>
        </tr>
        <tr>
          <td>F9</td>
          <td>3</td>
          <td>6-m-x+x*p</td>
          <td>abs,Y</td>
          <td>mm....mm .</td>
          <td>SBC $9876,Y</td>
        </tr>
        <tr>
          <td>FD</td>
          <td>3</td>
          <td>6-m-x+x*p</td>
          <td>abs,X</td>
          <td>mm....mm .</td>
          <td>SBC $9876,X</td>
        </tr>
        <tr>
          <td>FF</td>
          <td>4</td>
          <td>6-m</td>
          <td>long,X</td>
          <td>mm....mm .</td>
          <td>SBC $FEDCBA,X</td>
        </tr>
      </tbody>
    </table>
    <p class="added"><code>ADC</code> and <code>SBC</code> add to,
    and subtract from, the accumulator. When the m flag is 0, it is
    a 16-bit operation, and when the m flag is 1, it is an 8-bit
    operation. When the d flag is 0, binary arithmetic is used, and
    when the d flag is 1, <code>BCD</code> arithmetic is used. Note
    that like the NMOS 6502, but unlike the 65C02, decimal mode
    (i.e. when the d flag is 1) takes no additional cycles.</p>
    <p>The formula for <code>ADC</code> is:</p>
    <ul>
      <li>Accumulator = Accumulator + Data + Carry</li>
    </ul>
    <p class="added">The formula for <code>SBC</code> can be
    written several ways; one way is:</p>
    <ul>
      <li>Accumulator = Accumulator - Data - 1 + Carry</li>
    </ul>
    <p>In other words, the formula is accumulator = accumulator -
    data - 1 when the carry (i.e. the c flag) is 0, and accumulator
    = accumulator - data when the carry is 1.</p>
    <p>When the d flag is 0:</p>
    <ul>
      <li>The N Flag Is 0 When The High Bit Of The Result (Bit 15
      When The M Flag Is 0, Bit 7 When The M Flag Is 1) Is 0, and
      The N Flag Is 1 When The High Bit Of The Result Is 1.</li>
      <li>The V Flag Is 0 When There Is Not A Signed Arithmetic
      Overflow, and The V Flag Is 1 When There Is A Signed
      Arithmetic Overflow. For 8-Bit Signed Numbers,
      <code>$00</code> To <code>$7F</code> Represents 0 To 127, and
      <code>$80</code> To <code>$Ff</code> Represents -128 To -1;
      An 8-Bit Arithmetic Overflow Occurs When The Result Is
      Outside The Range -128 To 127. For 16-Bit Signed Numbers,
      <code>$0000</code> To <code>$7Fff</code> Represents 0 To
      32767, and <code>$8000</code> To <code>$Ffff</code>
      Represents -32768 To -1; A 16-Bit Arithmetic Overflow Occurs
      When The Result Is Outside The Range -32768 To 32767.</li>
      <li>The Z Flag Is 0 When The 16-Bit (When M Flag Is 0) Or
      8-Bit (When The M Flag Is 1) Result Is Nonzero, and The Z
      Flag Is 1 When The Result Is Zero.</li>
      <li>The C Flag Is 0 When There Is Not An Unsigned Carry, and
      The C Flag Is 1 When There Is An Unsigned Carry. For 8-Bit
      Unsigned Numbers, <code>$00</code> To <code>$Ff</code>
      Represents 0 To 255; For Addition, An 8-Bit Carry Occurs When
      The Result Is Greater Than 255. For 16-Bit Unsigned Numbers,
      <code>$0000</code> To <code>$Ffff</code> Represents 0 To
      65535; For Addition, An 16-Bit Carry Occurs When The Result
      Is Greater Than 65535. For Subtraction (8-Bit Or 16-Bit),
      There Is A Carry When The Accumulator Is Greater Than Or
      Equal To The Data.</li>
    </ul>
    <p>When the d flag is 1, the n, z, and c flags have the same
    meaning (i.e. the n flag reflects the high bit of the result,
    the z flag indicates when the result is zero, and the carry
    indicates when the result is outside the range 0 to 9999). The
    v flag is overwritten, but <code>BCD</code> is really an
    unsigned representation, so the v flag can be considered
    invalid, since it does not represent a signed arithmetic
    overflow.</p>
    <p>Example 1: If the accumulator is <code>$0001</code>, the m
    flag is 0, the d flag is 0, and the c flag is 1, then after
    <code>SBC</code> <code>#$2003</code></p>
    <ul>
      <li>The Accumulator Will Be <code>$Dffe</code></li>
      <li>The N Flag Will Be 1</li>
      <li>The V Flag Will Be 0</li>
      <li>The Z Flag Will Be 0</li>
      <li>The C Flag Will Be 0</li>
    </ul>
    <p>Example 2: If the accumulator is <code>$0001</code>, the m
    flag is 0, the d flag is 1, and the c flag is 1, then after
    <code>SBC</code> <code>#$2003</code></p>
    <ul>
      <li>The Accumulator Will Be <code>$7998</code></li>
      <li>The N Flag Will Be 0</li>
      <li>The Z Flag Will Be 0</li>
      <li>The C Flag Will Be 0</li>
    </ul>
  </section>
  <section>
    <h3><a id="6.1.1.2" name="6.1.1.2">6.1.1.2 <code>CMP</code>
    <code>CPX</code> <code>CPY</code></a></h3>
    <pre>
CoMPare (to accumulator)
ComPare to X register
ComPare to Y register
</pre>
    <table class="opcode">
      <thead>
        <tr>
          <th>OP</th>
          <th>LEN</th>
          <th>CYCLES</th>
          <th>MODE</th>
          <th>nvmxdizc e</th>
          <th>SYNTAX</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>C1</td>
          <td>2</td>
          <td>7-m+w</td>
          <td>(dir,X)</td>
          <td>m.....mm .</td>
          <td>CMP ($10,X)</td>
        </tr>
        <tr>
          <td>C3</td>
          <td>2</td>
          <td>5-m</td>
          <td>stk,S</td>
          <td>m.....mm .</td>
          <td>CMP $32,S</td>
        </tr>
        <tr>
          <td>C5</td>
          <td>2</td>
          <td>4-m+w</td>
          <td>dir</td>
          <td>m.....mm .</td>
          <td>CMP $10</td>
        </tr>
        <tr>
          <td>C7</td>
          <td>2</td>
          <td>7-m+w</td>
          <td>[dir]</td>
          <td>m.....mm .</td>
          <td>CMP [$10]</td>
        </tr>
        <tr>
          <td>C9</td>
          <td>3-m</td>
          <td>3-m</td>
          <td>imm</td>
          <td>m.....mm .</td>
          <td>CMP #$54</td>
        </tr>
        <tr>
          <td>CD</td>
          <td>3</td>
          <td>5-m</td>
          <td>abs</td>
          <td>m.....mm .</td>
          <td>CMP $9876</td>
        </tr>
        <tr>
          <td>CF</td>
          <td>4</td>
          <td>6-m</td>
          <td>long</td>
          <td>m.....mm .</td>
          <td>CMP $FEDBCA</td>
        </tr>
        <tr>
          <td>D1</td>
          <td>2</td>
          <td>7-m+w-x+x*p</td>
          <td>(dir),Y</td>
          <td>m.....mm .</td>
          <td>CMP ($10),Y</td>
        </tr>
        <tr>
          <td>D2</td>
          <td>2</td>
          <td>6-m+w</td>
          <td>(dir)</td>
          <td>m.....mm .</td>
          <td>CMP ($10)</td>
        </tr>
        <tr>
          <td>D3</td>
          <td>2</td>
          <td>8-m</td>
          <td>(stk,S),Y</td>
          <td>m.....mm .</td>
          <td>CMP ($32,S),Y</td>
        </tr>
        <tr>
          <td>D5</td>
          <td>2</td>
          <td>5-m+w</td>
          <td>dir,X</td>
          <td>m.....mm .</td>
          <td>CMP $10,X</td>
        </tr>
        <tr>
          <td>D7</td>
          <td>2</td>
          <td>7-m+w</td>
          <td>[dir],Y</td>
          <td>m.....mm .</td>
          <td>CMP [$10],Y</td>
        </tr>
        <tr>
          <td>D9</td>
          <td>3</td>
          <td>6-m-x+x*p</td>
          <td>abs,Y</td>
          <td>m.....mm .</td>
          <td>CMP $9876,Y</td>
        </tr>
        <tr>
          <td>DD</td>
          <td>3</td>
          <td>6-m-x+x*p</td>
          <td>abs,X</td>
          <td>m.....mm .</td>
          <td>CMP $9876,X</td>
        </tr>
        <tr>
          <td>DF</td>
          <td>4</td>
          <td>6-m</td>
          <td>long,X</td>
          <td>m.....mm .</td>
          <td>CMP $FEDCBA,X</td>
        </tr>
        <tr>
          <td>E0</td>
          <td>3-x</td>
          <td>3-x</td>
          <td>imm</td>
          <td>x.....xx .</td>
          <td>CPX #$54</td>
        </tr>
        <tr>
          <td>E4</td>
          <td>2</td>
          <td>4-x+w</td>
          <td>dir</td>
          <td>x.....xx .</td>
          <td>CPX $10</td>
        </tr>
        <tr>
          <td>EC</td>
          <td>3</td>
          <td>5-x</td>
          <td>abs</td>
          <td>x.....xx .</td>
          <td>CPX $9876</td>
        </tr>
        <tr>
          <td>C0</td>
          <td>3-x</td>
          <td>3-x</td>
          <td>imm</td>
          <td>x.....xx .</td>
          <td>CPY #$54</td>
        </tr>
        <tr>
          <td>C4</td>
          <td>2</td>
          <td>4-x+w</td>
          <td>dir</td>
          <td>x.....xx .</td>
          <td>CPY $10</td>
        </tr>
        <tr>
          <td>CC</td>
          <td>3</td>
          <td>5-x</td>
          <td>abs</td>
          <td>x.....xx .</td>
          <td>CPY $9876</td>
        </tr>
      </tbody>
    </table>
    <p class="added"><code>CMP</code>, <code>CPX</code>, and
    <code>CPY</code> compare the accumulator, X register, and Y
    register (respectively) to the data. <code>CMP</code> is a
    16-bit comparison when the m flag is 0, and an 8-bit comparison
    when the m flag is 1. <code>CPX</code> and <code>CPY</code> are
    16-bit comparisons when the x flag is 0, and 8-bit comparisons
    when the x flag is 1.</p>
    <p><code>CMP</code> is similar to <code>SBC</code>, except:</p>
    <ul>
      <li>A. It Is Always A Binary Subtraction (I.E. Sbc As Though
      The D Flag Was 0)</li>
      <li>B. It Does Not Include The Carry In The Formula (I.E.
      Register - Data; In Other Words, Sbc As Though The Carry Was
      Set Before The Sbc)</li>
      <li>C. The V Flag Is Not Affected</li>
      <li>D. The Result Is Only Reflected In The N, Z, and C Flags;
      The Accumulator, X Register, and Y Register Are Left
      Unchanged.</li>
    </ul>
    <p>Likewise for <code>CPX</code> and <code>CPY</code>, except
    the X and Y registers, respectively, are used instead of the
    accumulator.</p>
    <ul>
      <li>The N Flag Reflects The High Bit Of The Result.</li>
      <li>The Z Flag Reflects Whether The Result Is Zero.</li>
      <li>The C Flag Is 0 When The Register (Accumulator, X
      Register, Or Y Register) Is Less Than The Data, and The C
      Flag Is 1 When The Register Is Greater Than Or Equal To The
      Data.</li>
    </ul>
    <p>Example: If the accumulator is <code>$1234</code> and the m
    flag is 0, then after <code>CMP</code> <code>#$1234</code></p>
    <ul>
      <li>The N Flag Will Be 0</li>
      <li>The Z Flag Will Be 1</li>
      <li>The C Flag Will Be 1</li>
    </ul>
  </section>
  <section>
    <h3><a id="6.1.1.3" name="6.1.1.3">6.1.1.3 <code>DEC</code>
    <code>DEX</code> <code>DEY</code> <code>INC</code>
    <code>INX</code> <code>INY</code></a></h3>
    <pre>
DECrement
DEcrement X register
DEcrement Y register
INCrement
INcrement X register
INcrement Y register
</pre>
    <table class="opcode">
      <thead>
        <tr>
          <th>OP</th>
          <th>LEN</th>
          <th>CYCLES</th>
          <th>MODE</th>
          <th>nvmxdizc e</th>
          <th>SYNTAX</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>3A</td>
          <td>1</td>
          <td>2</td>
          <td>acc</td>
          <td>m.....m. .</td>
          <td>DEC</td>
        </tr>
        <tr>
          <td>C6</td>
          <td>2</td>
          <td>7-2*m+w</td>
          <td>dir</td>
          <td>m.....m. .</td>
          <td>DEC $10</td>
        </tr>
        <tr>
          <td>CE</td>
          <td>3</td>
          <td>8-2*m</td>
          <td>abs</td>
          <td>m.....m. .</td>
          <td>DEC $9876</td>
        </tr>
        <tr>
          <td>D6</td>
          <td>2</td>
          <td>8-2*m+w</td>
          <td>dir,X</td>
          <td>m.....m. .</td>
          <td>DEC $10,X</td>
        </tr>
        <tr>
          <td>DE</td>
          <td>3</td>
          <td>9-2*m</td>
          <td>abs,X</td>
          <td>m.....m. .</td>
          <td>DEC $9876,X</td>
        </tr>
        <tr>
          <td>CA</td>
          <td>1</td>
          <td>2</td>
          <td>imp</td>
          <td>x.....x. .</td>
          <td>DEX</td>
        </tr>
        <tr>
          <td>88</td>
          <td>1</td>
          <td>2</td>
          <td>imp</td>
          <td>x.....x. .</td>
          <td>DEY</td>
        </tr>
        <tr>
          <td>1A</td>
          <td>1</td>
          <td>2</td>
          <td>acc</td>
          <td>m.....m. .</td>
          <td>INC</td>
        </tr>
        <tr>
          <td>E6</td>
          <td>2</td>
          <td>7-2*m+w</td>
          <td>dir</td>
          <td>m.....m. .</td>
          <td>INC $10</td>
        </tr>
        <tr>
          <td>EE</td>
          <td>3</td>
          <td>8-2*m</td>
          <td>abs</td>
          <td>m.....m. .</td>
          <td>INC $9876</td>
        </tr>
        <tr>
          <td>F6</td>
          <td>2</td>
          <td>8-2*m+w</td>
          <td>dir,X</td>
          <td>m.....m. .</td>
          <td>INC $10,X</td>
        </tr>
        <tr>
          <td>FE</td>
          <td>3</td>
          <td>9-2*m</td>
          <td>abs,X</td>
          <td>m.....m. .</td>
          <td>INC $9876,X</td>
        </tr>
        <tr>
          <td>E8</td>
          <td>1</td>
          <td>2</td>
          <td>imp</td>
          <td>x.....x. .</td>
          <td>INX</td>
        </tr>
        <tr>
          <td>C8</td>
          <td>1</td>
          <td>2</td>
          <td>imp</td>
          <td>x.....x. .</td>
          <td>INY</td>
        </tr>
      </tbody>
    </table>
    <p class="added"><code>DEC</code>, <code>DEX</code>, and
    <code>DEY</code> decrement (i.e. subtract 1 from) and
    <code>INC</code>, <code>INX</code>, and <code>INY</code>
    increment (i.e. add 1 to) a register or the data.</p>
    <p><code>DEX</code>, <code>DEY</code> decrement the X and Y
    registers respectively, and <code>INX</code> and
    <code>INY</code> increment the X and Y registers respectively.
    <code>DEX</code>, <code>DEY</code>, <code>INX</code>, and
    <code>INY</code> are 16-bit operations when the x flag is 0 and
    8-bit operations when the x flag is 1.</p>
    <p>For accumulator addressing, <code>DEC</code> and
    <code>INC</code> decrement and increment the accumulator; for
    all other addressing modes, <code>DEC</code> and
    <code>INC</code> decrement and increment the data (at the
    memory location specified by the addressing mode) and the
    accumulator is not affected. <code>DEC</code> and
    <code>INC</code> are 16-bit operations when the m flag is 0 and
    8-bit operations when the m flag is 1.</p>
    <p>Assemblers may require or permit the following syntaxes for
    accumulator addressing for <code>DEC</code> and
    <code>INC</code></p>
    <pre>
DEA
DEC
DECA
DEC A
INA
INC
INCA
INC A
</pre>
    <p>For this reason, in some assemblers, the label A is reserved
    and cannot be used in source code.</p>
    <p>For all 6 instructions:</p>
    <ul>
      <li>The N Flag Reflects The High Bit Of The Result.</li>
      <li>The Z Flag Reflects Whether The Result Is Zero.</li>
    </ul>
    <p>Example: If the X register is <code>$7FFF</code> and the x
    flag is 0, then after <code>INX</code></p>
    <ul>
      <li>The X Register Will Be <code>$8000</code></li>
      <li>The N Flag Will Be 1</li>
      <li>The Z Flag Will Be 0</li>
    </ul>
  </section>
  <section>
    <h3><a id="6.1.2.1" name="6.1.2.1">6.1.2.1 <code>AND</code>
    <code>EOR</code> <code>ORA</code></a></h3>
    <pre>
bitwise AND
bitwise Exclusive OR
bitwise OR Accumulator
</pre>
    <table class="opcode">
      <thead>
        <tr>
          <th>OP</th>
          <th>LEN</th>
          <th>CYCLES</th>
          <th>MODE</th>
          <th>nvmxdizc e</th>
          <th>SYNTAX</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>21</td>
          <td>2</td>
          <td>7-m+w</td>
          <td>(dir,X)</td>
          <td>m.....m. .</td>
          <td>AND ($10,X)</td>
        </tr>
        <tr>
          <td>23</td>
          <td>2</td>
          <td>5-m</td>
          <td>stk,S</td>
          <td>m.....m. .</td>
          <td>AND $32,S</td>
        </tr>
        <tr>
          <td>25</td>
          <td>2</td>
          <td>4-m+w</td>
          <td>dir</td>
          <td>m.....m. .</td>
          <td>AND $10</td>
        </tr>
        <tr>
          <td>27</td>
          <td>2</td>
          <td>7-m+w</td>
          <td>[dir]</td>
          <td>m.....m. .</td>
          <td>AND [$10]</td>
        </tr>
        <tr>
          <td>29</td>
          <td>3-m</td>
          <td>3-m</td>
          <td>imm</td>
          <td>m.....m. .</td>
          <td>AND #$54</td>
        </tr>
        <tr>
          <td>2D</td>
          <td>3</td>
          <td>5-m</td>
          <td>abs</td>
          <td>m.....m. .</td>
          <td>AND $9876</td>
        </tr>
        <tr>
          <td>2F</td>
          <td>4</td>
          <td>6-m</td>
          <td>long</td>
          <td>m.....m. .</td>
          <td>AND $FEDBCA</td>
        </tr>
        <tr>
          <td>31</td>
          <td>2</td>
          <td>7-m+w-x+x*p</td>
          <td>(dir),Y</td>
          <td>m.....m. .</td>
          <td>AND ($10),Y</td>
        </tr>
        <tr>
          <td>32</td>
          <td>2</td>
          <td>6-m+w</td>
          <td>(dir)</td>
          <td>m.....m. .</td>
          <td>AND ($10)</td>
        </tr>
        <tr>
          <td>33</td>
          <td>2</td>
          <td>8-m</td>
          <td>(stk,S),Y</td>
          <td>m.....m. .</td>
          <td>AND ($32,S),Y</td>
        </tr>
        <tr>
          <td>35</td>
          <td>2</td>
          <td>5-m+w</td>
          <td>dir,X</td>
          <td>m.....m. .</td>
          <td>AND $10,X</td>
        </tr>
        <tr>
          <td>37</td>
          <td>2</td>
          <td>7-m+w</td>
          <td>[dir],Y</td>
          <td>m.....m. .</td>
          <td>AND [$10],Y</td>
        </tr>
        <tr>
          <td>39</td>
          <td>3</td>
          <td>6-m-x+x*p</td>
          <td>abs,Y</td>
          <td>m.....m. .</td>
          <td>AND $9876,Y</td>
        </tr>
        <tr>
          <td>3D</td>
          <td>3</td>
          <td>6-m-x+x*p</td>
          <td>abs,X</td>
          <td>m.....m. .</td>
          <td>AND $9876,X</td>
        </tr>
        <tr>
          <td>3F</td>
          <td>4</td>
          <td>6-m</td>
          <td>long,X</td>
          <td>m.....m. .</td>
          <td>AND $FEDCBA,X</td>
        </tr>
        <tr>
          <td>41</td>
          <td>2</td>
          <td>7-m+w</td>
          <td>(dir,X)</td>
          <td>m.....m. .</td>
          <td>EOR ($10,X)</td>
        </tr>
        <tr>
          <td>43</td>
          <td>2</td>
          <td>5-m</td>
          <td>stk,S</td>
          <td>m.....m. .</td>
          <td>EOR $32,S</td>
        </tr>
        <tr>
          <td>45</td>
          <td>2</td>
          <td>4-m+w</td>
          <td>dir</td>
          <td>m.....m. .</td>
          <td>EOR $10</td>
        </tr>
        <tr>
          <td>47</td>
          <td>2</td>
          <td>7-m+w</td>
          <td>[dir]</td>
          <td>m.....m. .</td>
          <td>EOR [$10]</td>
        </tr>
        <tr>
          <td>49</td>
          <td>3-m</td>
          <td>3-m</td>
          <td>imm</td>
          <td>m.....m. .</td>
          <td>EOR #$54</td>
        </tr>
        <tr>
          <td>4D</td>
          <td>3</td>
          <td>5-m</td>
          <td>abs</td>
          <td>m.....m. .</td>
          <td>EOR $9876</td>
        </tr>
        <tr>
          <td>4F</td>
          <td>4</td>
          <td>6-m</td>
          <td>long</td>
          <td>m.....m. .</td>
          <td>EOR $FEDBCA</td>
        </tr>
        <tr>
          <td>51</td>
          <td>2</td>
          <td>7-m+w-x+x*p</td>
          <td>(dir),Y</td>
          <td>m.....m. .</td>
          <td>EOR ($10),Y</td>
        </tr>
        <tr>
          <td>52</td>
          <td>2</td>
          <td>6-m+w</td>
          <td>(dir)</td>
          <td>m.....m. .</td>
          <td>EOR ($10)</td>
        </tr>
        <tr>
          <td>53</td>
          <td>2</td>
          <td>8-m</td>
          <td>(stk,S),Y</td>
          <td>m.....m. .</td>
          <td>EOR ($32,S),Y</td>
        </tr>
        <tr>
          <td>55</td>
          <td>2</td>
          <td>5-m+w</td>
          <td>dir,X</td>
          <td>m.....m. .</td>
          <td>EOR $10,X</td>
        </tr>
        <tr>
          <td>57</td>
          <td>2</td>
          <td>7-m+w</td>
          <td>[dir],Y</td>
          <td>m.....m. .</td>
          <td>EOR [$10],Y</td>
        </tr>
        <tr>
          <td>59</td>
          <td>3</td>
          <td>6-m-x+x*p</td>
          <td>abs,Y</td>
          <td>m.....m. .</td>
          <td>EOR $9876,Y</td>
        </tr>
        <tr>
          <td>5D</td>
          <td>3</td>
          <td>6-m-x+x*p</td>
          <td>abs,X</td>
          <td>m.....m. .</td>
          <td>EOR $9876,X</td>
        </tr>
        <tr>
          <td>5F</td>
          <td>4</td>
          <td>6-m</td>
          <td>long,X</td>
          <td>m.....m. .</td>
          <td>EOR $FEDCBA,X</td>
        </tr>
        <tr>
          <td>01</td>
          <td>2</td>
          <td>7-m+w</td>
          <td>(dir,X)</td>
          <td>m.....m. .</td>
          <td>ORA ($10,X)</td>
        </tr>
        <tr>
          <td>03</td>
          <td>2</td>
          <td>5-m</td>
          <td>stk,S</td>
          <td>m.....m. .</td>
          <td>ORA $32,S</td>
        </tr>
        <tr>
          <td>05</td>
          <td>2</td>
          <td>4-m+w</td>
          <td>dir</td>
          <td>m.....m. .</td>
          <td>ORA $10</td>
        </tr>
        <tr>
          <td>07</td>
          <td>2</td>
          <td>7-m+w</td>
          <td>[dir]</td>
          <td>m.....m. .</td>
          <td>ORA [$10]</td>
        </tr>
        <tr>
          <td>09</td>
          <td>3-m</td>
          <td>3-m</td>
          <td>imm</td>
          <td>m.....m. .</td>
          <td>ORA #$54</td>
        </tr>
        <tr>
          <td>0D</td>
          <td>3</td>
          <td>5-m</td>
          <td>abs</td>
          <td>m.....m. .</td>
          <td>ORA $9876</td>
        </tr>
        <tr>
          <td>0F</td>
          <td>4</td>
          <td>6-m</td>
          <td>long</td>
          <td>m.....m. .</td>
          <td>ORA $FEDBCA</td>
        </tr>
        <tr>
          <td>11</td>
          <td>2</td>
          <td>7-m+w-x+x*p</td>
          <td>(dir),Y</td>
          <td>m.....m. .</td>
          <td>ORA ($10),Y</td>
        </tr>
        <tr>
          <td>12</td>
          <td>2</td>
          <td>6-m+w</td>
          <td>(dir)</td>
          <td>m.....m. .</td>
          <td>ORA ($10)</td>
        </tr>
        <tr>
          <td>13</td>
          <td>2</td>
          <td>8-m</td>
          <td>(stk,S),Y</td>
          <td>m.....m. .</td>
          <td>ORA ($32,S),Y</td>
        </tr>
        <tr>
          <td>15</td>
          <td>2</td>
          <td>5-m+w</td>
          <td>dir,X</td>
          <td>m.....m. .</td>
          <td>ORA $10,X</td>
        </tr>
        <tr>
          <td>17</td>
          <td>2</td>
          <td>7-m+w</td>
          <td>[dir],Y</td>
          <td>m.....m. .</td>
          <td>ORA [$10],Y</td>
        </tr>
        <tr>
          <td>19</td>
          <td>3</td>
          <td>6-m-x+x*p</td>
          <td>abs,Y</td>
          <td>m.....m. .</td>
          <td>ORA $9876,Y</td>
        </tr>
        <tr>
          <td>1D</td>
          <td>3</td>
          <td>6-m-x+x*p</td>
          <td>abs,X</td>
          <td>m.....m. .</td>
          <td>ORA $9876,X</td>
        </tr>
        <tr>
          <td>1F</td>
          <td>4</td>
          <td>6-m</td>
          <td>long,X</td>
          <td>m.....m. .</td>
          <td>ORA $FEDCBA,X</td>
        </tr>
      </tbody>
    </table>
    <p class="added"><code>AND</code>, <code>EOR</code>, and
    <code>ORA</code> bitwise And, bitwise Exclusive-Or, and bitwise
    (inclusive) Or the accumulator with the data, and store the
    result in the accumulator. These instructions are 16-bit
    operations when the m flag is 0, and 8-bit operations when the
    m flag is 1.</p>
    <p>For <code>AND</code>, if bit 0 of the accumulator (input)
    and bit 0 of the data are both 1, then bit 0 of the accumulator
    (result) will be 1, otherwise, bit 0 of the accumulator result
    will be 0. And so on for bits 1, 2, 3, etc.</p>
    <p>For <code>EOR</code>, if bit 0 of the accumulator (input)
    and bit 0 of the data have the same value (e.g. both are zero),
    then bit 0 of the accumulator (result) will be 0, otherwise,
    bit 0 of the accumulator result will be 1. And so on for bits
    1, 2, 3, etc.</p>
    <p>For <code>ORA</code>, if bit 0 of the accumulator (input)
    and bit 0 of the data are both 0, then bit 0 of the accumulator
    (result) will be 0, otherwise, bit 0 of the accumulator result
    will be 1. And so on for bits 1, 2, 3, etc.</p>
    <p>For all 3 instructions:</p>
    <ul>
      <li>The N Flag Reflects The High Bit Of The Result.</li>
      <li>The Z Flag Reflects Whether The Result Is Zero.</li>
    </ul>
    <p>Example: If the accumulator is <code>$0F06</code> and the m
    flag is 0, then after <code>EOR</code> <code>#$F103</code></p>
    <ul>
      <li>The Accumulator Will Be <code>$Fe05</code></li>
      <li>The N Flag Will Be 1</li>
      <li>The Z Flag Will Be 0</li>
    </ul>
  </section>
  <section>
    <h3><a id="6.1.2.2" name="6.1.2.2">6.1.2.2
    <code>BIT</code></a></h3>
    <pre>test BITs
</pre>
    <table class="opcode">
      <thead>
        <tr>
          <th>OP</th>
          <th>LEN</th>
          <th>CYCLES</th>
          <th>MODE</th>
          <th>nvmxdizc e</th>
          <th>SYNTAX</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>24</td>
          <td>2</td>
          <td>4-m+w</td>
          <td>dir</td>
          <td>mm....m. .</td>
          <td>BIT $10</td>
        </tr>
        <tr>
          <td>2C</td>
          <td>3</td>
          <td>5-m</td>
          <td>abs</td>
          <td>mm....m. .</td>
          <td>BIT $9876</td>
        </tr>
        <tr>
          <td>34</td>
          <td>2</td>
          <td>5-m+w</td>
          <td>dir,X</td>
          <td>mm....m. .</td>
          <td>BIT $10,X</td>
        </tr>
        <tr>
          <td>3C</td>
          <td>3</td>
          <td>6-m-x+x*p</td>
          <td>abs,X</td>
          <td>mm....m. .</td>
          <td>BIT $9876,X</td>
        </tr>
        <tr>
          <td>89</td>
          <td>3-m</td>
          <td>3-m</td>
          <td>imm</td>
          <td>......m. .</td>
          <td>BIT #$54</td>
        </tr>
      </tbody>
    </table>
    <p class="added"><code>BIT</code> tests the bits of the data
    with the bits of the accumulator. It is a 16-bit operation when
    the m flag is 0, and an 8-bit operation when the m flag is
    1.</p>
    <p>Just as <code>CMP</code> is similar to <code>SBC</code>
    without overwriting the accumulator, <code>BIT</code> performs
    the same function as <code>AND</code>, but <code>BIT</code>
    only uses the result to set flags and does not overwrite the
    accumulator.</p>
    <p>Immediate addressing only affects the z flag (with the
    result of the bitwise And), but does not affect the n and v
    flags. All other addressing modes of <code>BIT</code> affect
    the n, v, and z flags. This is the only instruction in the 6502
    family where the flags affected depends on the addressing
    mode.</p>
    <ul>
      <li>The N Flag Reflects The High Bit Of The Data (Note: Just
      The Data, Not The Bitwise and Of The Accumulator and The
      Data).</li>
      <li>The V Flag Reflects The Second Highest Bit Of The Data
      (I.E. Bit 14 Of The Data When The M Flag Is 0, and Bit 6 Of
      The Data When The M Flag Is 1, and Again, Just The Data, Not
      The Bitwise and).</li>
      <li>The Z Flag Reflects Whether The Result (Of The Bitwise
      and) Is Zero.</li>
    </ul>
    <p>Example: If the accumulator is <code>$43</code>, the
    <code>DBR</code> is <code>$12</code>, the m flag is 1, and</p>
    <ul>
      <li><code>$12Abcd</code> Contains <code>$9C</code></li>
    </ul>
    <p class="added">then after <code>BIT</code>
    <code>$ABCD</code></p>
    <ul>
      <li>The N Flag Will Be 1</li>
      <li>The V Flag Will Be 0</li>
      <li>The Z Flag Will Be 1</li>
    </ul>
  </section>
  <section>
    <h3><a id="6.1.2.3" name="6.1.2.3">6.1.2.3 <code>TRB</code>
    <code>TSB</code></a></h3>
    <pre>
Test and Reset Bits
Test and Set Bits
</pre>
    <table class="opcode">
      <thead>
        <tr>
          <th>OP</th>
          <th>LEN</th>
          <th>CYCLES</th>
          <th>MODE</th>
          <th>nvmxdizc e</th>
          <th>SYNTAX</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>14</td>
          <td>2</td>
          <td>7-2*m+w</td>
          <td>dir</td>
          <td>......m. .</td>
          <td>TRB $10</td>
        </tr>
        <tr>
          <td>1C</td>
          <td>3</td>
          <td>8-2*m</td>
          <td>abs</td>
          <td>......m. .</td>
          <td>TRB $9876</td>
        </tr>
        <tr>
          <td>04</td>
          <td>2</td>
          <td>7-2*m+w</td>
          <td>dir</td>
          <td>......m. .</td>
          <td>TSB $10</td>
        </tr>
        <tr>
          <td>0C</td>
          <td>3</td>
          <td>8-2*m</td>
          <td>abs</td>
          <td>......m. .</td>
          <td>TSB $9876</td>
        </tr>
      </tbody>
    </table>
    <p class="added"><code>TRB</code> and <code>TSB</code> test the
    bits of the data with the bits of the accumulator (using a
    bitwise And, like <code>BIT</code>), then reset (i.e. clear) or
    set (respectively) the bits of the data that are ones in the
    accumulator. The accumulator is unchanged. These are 16-bit
    operations when the m flag is 0, and 8-bit operations when the
    m flag is 1.</p>
    <p>For example, if the accumulator is <code>$43</code> and the
    m flag is 1, then <code>TRB</code> resets (i.e. clears) bits 0,
    1, and 6 of the data, and does not affect the other bits (bits
    2, 3, 4, 5, and 7). Under the same condition, <code>TSB</code>
    sets bits 0, 1, and 6 of the data and does not affect the other
    bits.</p>
    <ul>
      <li>The Z Flag Reflects Whether The Result (Of The Bitwise
      and) Is Zero.</li>
    </ul>
    <p>Example: If the accumulator is <code>$43</code>, the
    <code>DBR</code> is <code>$12</code>, the m flag is 1, and</p>
    <ul>
      <li><code>$12Abcd</code> Contains <code>$9C</code></li>
    </ul>
    <p class="added">then after <code>TSB</code>
    <code>$ABCD</code></p>
    <ul>
      <li>The Z Flag Will Be 1</li>
      <li><code>$12Abcd</code> Will Contain <code>$Df</code></li>
    </ul>
  </section>
  <section>
    <h3><a id="6.1.3" name="6.1.3">6.1.3 <code>ASL</code>
    <code>LSR</code> <code>ROL</code> <code>ROR</code></a></h3>
    <pre>
Arithmetic Shift Left
Logical Shift Right
ROtate Left
ROtate Right
</pre>
    <table class="opcode">
      <thead>
        <tr>
          <th>OP</th>
          <th>LEN</th>
          <th>CYCLES</th>
          <th>MODE</th>
          <th>nvmxdizc e</th>
          <th>SYNTAX</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>06</td>
          <td>2</td>
          <td>7-2*m+w</td>
          <td>dir</td>
          <td>m.....mm .</td>
          <td>ASL $10</td>
        </tr>
        <tr>
          <td>0A</td>
          <td>1</td>
          <td>2</td>
          <td>acc</td>
          <td>m.....mm .</td>
          <td>ASL</td>
        </tr>
        <tr>
          <td>0E</td>
          <td>3</td>
          <td>8-2*m</td>
          <td>abs</td>
          <td>m.....mm .</td>
          <td>ASL $9876</td>
        </tr>
        <tr>
          <td>16</td>
          <td>2</td>
          <td>8-2*m+w</td>
          <td>dir,X</td>
          <td>m.....mm .</td>
          <td>ASL $10,X</td>
        </tr>
        <tr>
          <td>1E</td>
          <td>3</td>
          <td>9-2*m</td>
          <td>abs,X</td>
          <td>m.....mm .</td>
          <td>ASL $9876,X</td>
        </tr>
        <tr>
          <td>46</td>
          <td>2</td>
          <td>7-2*m+w</td>
          <td>dir</td>
          <td>0.....m* .</td>
          <td>LSR $10</td>
        </tr>
        <tr>
          <td>4A</td>
          <td>1</td>
          <td>2</td>
          <td>acc</td>
          <td>0.....m* .</td>
          <td>LSR</td>
        </tr>
        <tr>
          <td>4E</td>
          <td>3</td>
          <td>8-2*m</td>
          <td>abs</td>
          <td>0.....m* .</td>
          <td>LSR $9876</td>
        </tr>
        <tr>
          <td>56</td>
          <td>2</td>
          <td>8-2*m+w</td>
          <td>dir,X</td>
          <td>0.....m* .</td>
          <td>LSR $10,X</td>
        </tr>
        <tr>
          <td>5E</td>
          <td>3</td>
          <td>9-2*m</td>
          <td>abs,X</td>
          <td>0.....m* .</td>
          <td>LSR $9876,X</td>
        </tr>
        <tr>
          <td>26</td>
          <td>2</td>
          <td>7-2*m+w</td>
          <td>dir</td>
          <td>m.....mm .</td>
          <td>ROL $10</td>
        </tr>
        <tr>
          <td>2A</td>
          <td>1</td>
          <td>2</td>
          <td>acc</td>
          <td>m.....mm .</td>
          <td>ROL</td>
        </tr>
        <tr>
          <td>2E</td>
          <td>3</td>
          <td>8-2*m</td>
          <td>abs</td>
          <td>m.....mm .</td>
          <td>ROL $9876</td>
        </tr>
        <tr>
          <td>36</td>
          <td>2</td>
          <td>8-2*m+w</td>
          <td>dir,X</td>
          <td>m.....mm .</td>
          <td>ROL $10,X</td>
        </tr>
        <tr>
          <td>3E</td>
          <td>3</td>
          <td>9-2*m</td>
          <td>abs,X</td>
          <td>m.....mm .</td>
          <td>ROL $9876,X</td>
        </tr>
        <tr>
          <td>66</td>
          <td>2</td>
          <td>7-2*m+w</td>
          <td>dir</td>
          <td>m.....m* .</td>
          <td>ROR $10</td>
        </tr>
        <tr>
          <td>6A</td>
          <td>1</td>
          <td>2</td>
          <td>acc</td>
          <td>m.....m* .</td>
          <td>ROR</td>
        </tr>
        <tr>
          <td>6E</td>
          <td>3</td>
          <td>8-2*m</td>
          <td>abs</td>
          <td>m.....m* .</td>
          <td>ROR $9876</td>
        </tr>
        <tr>
          <td>76</td>
          <td>2</td>
          <td>8-2*m+w</td>
          <td>dir,X</td>
          <td>m.....m* .</td>
          <td>ROR $10,X</td>
        </tr>
        <tr>
          <td>7E</td>
          <td>3</td>
          <td>9-2*m</td>
          <td>abs,X</td>
          <td>m.....m* .</td>
          <td>ROR $9876,X</td>
        </tr>
      </tbody>
    </table>
    <p class="added"><code>ASL</code>, <code>LSR</code>,
    <code>ROL</code>, and <code>ROR</code> shift the accumulator or
    the data left (<code>ASL</code> and <code>ROL</code>) and right
    (<code>LSR</code> and <code>ROR</code>). They are 16-bit
    operations when the m flag is 0, and 8-bit operations when the
    m flag is 1.</p>
    <p>For accumulator addressing, the accumulator is shifted; for
    all other addressing modes, the data (at the memory location
    specified by the addressing mode) is shifted and the
    accumulator is not affected.</p>
    <p><code>ASL</code> shifts left; a zero is shifted into the low
    bit (bit 0); the high bit (bit 15 when the m flag is one, bit 7
    when the m flag is 0) is shifted into the c flag.</p>
    <p><code>LSR</code> shifts right; a zero is shifted into the
    high bit; the low bit is shifted into the c flag.</p>
    <p><code>ROL</code> shifts left; the (input) c flag is shifted
    into the low bit; the high bit is shifted into the c flag
    (result).</p>
    <p><code>ROR</code> shifts right; the (input) c flag is shifted
    into the high bit; the low bit is shifted into the c flag
    (result).</p>
    <p>For all 4 instructions:</p>
    <ul>
      <li>The N Flag Reflects The High Bit Of The Result.</li>
      <li>The Z Flag Reflects Whether The Result Is Zero.</li>
    </ul>
    <p>Assemblers may require or permit the following syntaxes for
    accumulator addressing</p>
    <pre>
ASL
ASLA
ASL A
LSR
LSRA
LSR A
ROL
ROLA
ROL A
ROR
RORA
ROR A
</pre>
    <p>Again, for this reason, in some assemblers, the label A is
    reserved and cannot be used in source code.</p>
    <p>Note that for absolute,X addressing, when the m flag is 1,
    the cycle count matches the NMOS 6502 timing (7 cycles always)
    rather than the 65C02 (6 cycles if a page boundary was not
    crossed).</p>
    <p>Example: If the <code>DBR</code> is <code>$12</code>, the m
    flag is 1, and</p>
    <ul>
      <li><code>$12Abcd</code> Contains <code>$8F</code></li>
    </ul>
    <p class="added">then after <code>ASL</code>
    <code>$ABCD</code></p>
    <ul>
      <li><code>$12Abcd</code> Will Contain <code>$1E</code></li>
      <li>The N Flag Will Be 0</li>
      <li>The Z Flag Will Be 0</li>
      <li>The C Flag Will Be 1</li>
    </ul>
  </section>
  <section>
    <h3><a id="6.2.1.1" name="6.2.1.1">6.2.1.1 <code>BCC</code>
    <code>BCS</code> <code>BEQ</code> <code>BMI</code>
    <code>BNE</code> <code>BPL</code> <code>BRA</code>
    <code>BVC</code> <code>BVS</code></a></h3>
    <pre>
Branch if Carry Clear
Branch if Carry Set
Branch if EQual
Branch if MInus
Branch if Not Equal
Branch if PLus
BRanch Always
Branch if oVerflow Clear
Branch if oVerflow Set
</pre>
    <table class="opcode">
      <thead>
        <tr>
          <th>OP</th>
          <th>LEN</th>
          <th>CYCLES</th>
          <th>MODE</th>
          <th>nvmxdizc e</th>
          <th>SYNTAX</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>90</td>
          <td>2</td>
          <td>2+t+t*e*p</td>
          <td>rel8</td>
          <td>........ .</td>
          <td>BCC LABEL</td>
        </tr>
        <tr>
          <td>B0</td>
          <td>2</td>
          <td>2+t+t*e*p</td>
          <td>rel8</td>
          <td>........ .</td>
          <td>BCS LABEL</td>
        </tr>
        <tr>
          <td>F0</td>
          <td>2</td>
          <td>2+t+t*e*p</td>
          <td>rel8</td>
          <td>........ .</td>
          <td>BEQ LABEL</td>
        </tr>
        <tr>
          <td>30</td>
          <td>2</td>
          <td>2+t+t*e*p</td>
          <td>rel8</td>
          <td>........ .</td>
          <td>BMI LABEL</td>
        </tr>
        <tr>
          <td>D0</td>
          <td>2</td>
          <td>2+t+t*e*p</td>
          <td>rel8</td>
          <td>........ .</td>
          <td>BNE LABEL</td>
        </tr>
        <tr>
          <td>10</td>
          <td>2</td>
          <td>2+t+t*e*p</td>
          <td>rel8</td>
          <td>........ .</td>
          <td>BPL LABEL</td>
        </tr>
        <tr>
          <td>80</td>
          <td>2</td>
          <td>3+e*p</td>
          <td>rel8</td>
          <td>........ .</td>
          <td>BRA LABEL</td>
        </tr>
        <tr>
          <td>50</td>
          <td>2</td>
          <td>2+t+t*e*p</td>
          <td>rel8</td>
          <td>........ .</td>
          <td>BVC LABEL</td>
        </tr>
        <tr>
          <td>70</td>
          <td>2</td>
          <td>2+t+t*e*p</td>
          <td>rel8</td>
          <td>........ .</td>
          <td>BVS LABEL</td>
        </tr>
      </tbody>
    </table>
    <p class="added"><code>BRA</code> unconditionally branches; the
    other 8 instructions branch based on the value of the n, v, z,
    or c flag. These instructions can branch -128 to 127 bytes from
    the address of the next instruction (i.e. the address of the
    instruction after the branch instruction); since all of these
    branch instructions are 2 byte instructions, that means the
    branch can be -126 to 129 bytes from the address of the branch
    instruction.</p>
    <p>Note, however, a page boundary is crossed when the branch
    destination is on a different page than the next instruction
    (again, the instruction after the branch instruction). This
    means that</p>
    <pre>
LABEL BRA LABEL+2 ; 3 cycles
</pre>
    <p class="added">always takes 3 cycles, no matter where the
    <code>BRA</code> instruction is located in memory, since the
    branch destination is the next instruction, i.e. they are the
    same address, and thus on the same page.</p>
    <pre>
BCC branches if the c flag is 0
BCS branches if the c flag is 1
BEQ branches if the z flag is 1
BMI branches if the n flag is 1
BNE branches if the z flag is 0
BPL branches if the n flag is 0
BVC branches if the v flag is 0
BVS branches if the v flag is 1
</pre>
    <p>The names <code>BEQ</code> and <code>BNE</code> come from
    the fact that these two instructions often follow a compare
    (<code>CMP</code>, <code>CPX</code>, or <code>CPY</code>) and
    thus will branch if the register and the data were equal
    (<code>BEQ</code>) or not equal (<code>BNE</code>).</p>
    <p>In some assemblers, <code>BGE</code> (Branch if Greater than
    or Equal) and <code>BLT</code> (Branch if Less Than) are
    synonyms for <code>BCS</code> and <code>BCC</code>,
    respectively. The former names come from the fact the
    <code>CMP</code>, <code>CPX</code>, and <code>CPY</code> clear
    the c flag if the register was less than the data, and set the
    c flag if the register was greater than or equal to the
    data.</p>
    <p>Note that <code>BRA</code> actually has the same timing as
    the other instructions; the cycle count formula is different
    because there is no branch not taken case.</p>
    <p>Example: If the z flag is 0, then a <code>BNE</code>
    <code>$C023</code> at <code>$ABC000</code> will branch to
    <code>$ABC023</code>. (The displacement is <code>$21</code>
    since the instruction after the <code>BNE</code> is at
    <code>$ABC002</code>.)</p>
  </section>
  <section>
    <h3><a id="6.2.1.2" name="6.2.1.2">6.2.1.2
    <code>BRL</code></a></h3>
    <pre>
BRanch Long
</pre>
    <table class="opcode">
      <thead>
        <tr>
          <th>OP</th>
          <th>LEN</th>
          <th>CYCLES</th>
          <th>MODE</th>
          <th>nvmxdizc e</th>
          <th>SYNTAX</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>82</td>
          <td>3</td>
          <td>4</td>
          <td>rel16</td>
          <td>........ .</td>
          <td>BRL LABEL</td>
        </tr>
      </tbody>
    </table>
    <p class="added"><code>BRL</code> is like <code>BRA</code>,
    except that the branch displacement is 16 bits, instead of 8
    bits, which means it can branch -32768 to 32767 bytes from the
    address of the next instruction (or -32765 to 32770 bytes from
    the address of the <code>BRL</code> instruction). However,
    since <code>BRL</code> wraps at bank boundaries, this means it
    can branch anywhere within the current (program) bank.</p>
    <p><code>BRL</code> is one cycle longer than <code>JMP</code>
    absolute (which also can jump anywhere within the current
    bank). The reason <code>BRL</code> is used is for code (e.g. a
    section of code, or even an entire program) that can run no
    matter what address it is located at (in other words, its
    address isn't known until run time).</p>
    <p>Example: A <code>BRL</code> <code>$C045</code> at
    <code>$ABC000</code> will branch to <code>$ABC045</code>. (The
    displacement is <code>$0042</code> since the instruction after
    the <code>BRL</code> is at <code>$ABC003</code>.)</p>
  </section>
  <section>
    <h3><a id="6.2.2.1" name="6.2.2.1">6.2.2.1 <code>JMP</code>
    <code>JSL</code> <code>JSR</code></a></h3>
    <pre>
JuMP
Jump to Subroutine Long
Jump to SubRoutine
</pre>
    <table class="opcode">
      <thead>
        <tr>
          <th>OP</th>
          <th>LEN</th>
          <th>CYCLES</th>
          <th>MODE</th>
          <th>nvmxdizc e</th>
          <th>SYNTAX</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>4C</td>
          <td>3</td>
          <td>3</td>
          <td>abs</td>
          <td>........ .</td>
          <td>JMP $1234</td>
        </tr>
        <tr>
          <td>5C</td>
          <td>4</td>
          <td>4</td>
          <td>long</td>
          <td>........ .</td>
          <td>JMP $FEDCBA</td>
        </tr>
        <tr>
          <td>6C</td>
          <td>3</td>
          <td>5</td>
          <td>(abs)</td>
          <td>........ .</td>
          <td>JMP ($1234)</td>
        </tr>
        <tr>
          <td>7C</td>
          <td>3</td>
          <td>6</td>
          <td>(abs,X)</td>
          <td>........ .</td>
          <td>JMP ($1234,X)</td>
        </tr>
        <tr>
          <td>DC</td>
          <td>3</td>
          <td>6</td>
          <td>[abs]</td>
          <td>........ .</td>
          <td>JMP [$1234]</td>
        </tr>
        <tr>
          <td>22</td>
          <td>4</td>
          <td>8</td>
          <td>long</td>
          <td>........ .</td>
          <td>JSL $123456</td>
        </tr>
        <tr>
          <td>20</td>
          <td>3</td>
          <td>6</td>
          <td>abs</td>
          <td>........ .</td>
          <td>JSR $1234</td>
        </tr>
        <tr>
          <td>FC</td>
          <td>3</td>
          <td>8</td>
          <td>(abs,X)</td>
          <td>........ .</td>
          <td>JSR ($1234,X)</td>
        </tr>
      </tbody>
    </table>
    <p class="added"><code>JMP</code> jumps to the address
    specified by the addressing mode. absolute, (absolute) and
    (absolute,X) addressing jump to an address within the current
    program bank; [absolute] and long addressing use a 24-bit
    address and can jump to any bank.</p>
    <p>Note that <code>JMP</code> (absolute) is 5 cycles, same as
    the NMOS 6502, but different from the 65C02 (6 cycles).</p>
    <p>Again, in some assemblers, for [absolute] and/or long
    addressing, <code>JML</code> is a synonym for <code>JMP</code>.
    Also, some assemblers allow the syntax <code>JML</code>
    (absolute) for opcode <code>$DC</code> (i.e. <code>JMP</code>
    [absolute]), which is a 24-bit pointer, rather than a 16-bit
    pointer. Use of [absolute] is more consistent with the syntax
    (direct) and [direct], where parentheses indicate a 16-bit
    pointer, and square brackets indicate a 24-bit pointer.</p>
    <p><code>JSL</code> pushes the K register (i.e. program bank
    register), then pushes the 16-bit address (high byte first,
    then low byte) of the <code>JSL</code> instruction plus 3 (one
    less than the address of the next instruction), then jumps to
    the address specified by the operand. Thus, if the
    <code>JSL</code> instruction (i.e. the <code>$22</code> opcode)
    is at <code>$12FFFD</code>, then the bytes pushed are (in
    order): <code>$12</code>, <code>$00</code>, and
    <code>$00</code>, rather than <code>$13</code>,
    <code>$00</code>, and <code>$00</code>.</p>
    <p><code>JSR</code> pushes the 16-bit address (i.e. the program
    counter) of the <code>JSR</code> instruction plus 2 onto the
    stack, and jumps to an address within the current program bank.
    In other words, the address pushed is one less than the address
    of the next instruction. The high byte is pushed first, then
    the low byte is pushed.</p>
    <p>Some assemblers allow <code>JSR</code> to be a synonym for
    <code>JSL</code> when a 24-bit address is used with
    <code>JSR</code>. In general, you would be well advised not to
    utilize this; i.e. not use <code>JSR</code> in place of
    <code>JSL</code>. A <code>JSR</code> pushes two bytes and is
    matched with an <code>RTS</code>; a <code>JSL</code> pushes
    three bytes and is matched with an <code>RTL</code>. A
    <code>JSR</code> LABEL that sometimes pushes two bytes (i.e.
    for absolute addressing) and sometimes pushes three bytes (i.e.
    for long addressing) can result in code that is quite difficult
    to follow and/or debug.</p>
    <p>Example: If the S register is <code>$01FF</code>, then a
    <code>JSR</code> <code>$ABCD</code> at <code>$123456</code></p>
    <ul>
      <li>Stores <code>$34</code> At <code>$0001Ff</code></li>
      <li>Stores <code>$58</code> At <code>$0001Fe</code></li>
    </ul>
    <p class="added">then jumps to <code>$12ABCD</code>, and</p>
    <ul>
      <li>The S Register Will Be <code>$01Fd</code></li>
    </ul>
  </section>
  <section>
    <h3><a id="6.2.2.2" name="6.2.2.2">6.2.2.2 <code>RTL</code>
    <code>RTS</code></a></h3>
    <pre>
ReTurn from subroutine Long
ReTurn from Subroutine
</pre>
    <table class="opcode">
      <thead>
        <tr>
          <th>OP</th>
          <th>LEN</th>
          <th>CYCLES</th>
          <th>MODE</th>
          <th>nvmxdizc e</th>
          <th>SYNTAX</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>6B</td>
          <td>1</td>
          <td>6</td>
          <td>imp</td>
          <td>........ .</td>
          <td>RTL</td>
        </tr>
        <tr>
          <td>60</td>
          <td>1</td>
          <td>6</td>
          <td>imp</td>
          <td>........ .</td>
          <td>RTS</td>
        </tr>
      </tbody>
    </table>
    <p class="added"><code>RTL</code> returns from a subroutine
    called with <code>JSL</code> (from any bank). It pulls the low
    byte, then the high byte of the program counter from the stack,
    then increments the program counter, then pulls the K register
    (i.e. the program bank register) from the stack. This means
    that if <code>$FF</code>, <code>$FF</code>, and
    <code>$12</code> are pulled from the stack, the instruction at
    <code>$120000</code> (rather than <code>$130000</code>) will be
    executed next.</p>
    <p><code>RTS</code> returns from a subroutine called with
    <code>JSR</code> (within the current program bank). It pulls
    the low byte, then the high byte of the program counter from
    the stack, then increments the program counter.</p>
    <p>Example: if the K register is <code>$12</code>, the S
    register is <code>$01FD</code>, and</p>
    <ul>
      <li><code>$0001Fe</code> Contains <code>$56</code></li>
      <li><code>$0001Ff</code> Contains <code>$34</code></li>
    </ul>
    <p class="added">then an <code>RTS</code> will return to
    <code>$123457</code>, and</p>
    <ul>
      <li>The S Register Will Be <code>$01Ff</code></li>
    </ul>
  </section>
  <section>
    <h3><a id="6.3.1" name="6.3.1">6.3.1 <code>BRK</code>
    <code>COP</code></a></h3>
    <pre>
BReaKpoint
COProcessor
</pre>
    <table class="opcode">
      <thead>
        <tr>
          <th>OP</th>
          <th>LEN</th>
          <th>CYCLES</th>
          <th>MODE</th>
          <th>nvmxdizc e</th>
          <th>SYNTAX</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>00</td>
          <td>1</td>
          <td>8-e</td>
          <td>imp</td>
          <td>....01.. .</td>
          <td>BRK</td>
        </tr>
        <tr>
          <td>02</td>
          <td>2</td>
          <td>8-e</td>
          <td>imm</td>
          <td>....01.. .</td>
          <td>COP #$12</td>
        </tr>
      </tbody>
    </table>
    <pre>
BRK and COP are software interrupts.
</pre>
    <p>In native mode, <code>BRK</code> and <code>COP</code> push
    the K register (i.e. program bank register), then push the
    16-bit address (again high byte first, then low byte) of the
    <code>BRK</code> or <code>COP</code> instruction plus 2, then
    push the P register, then jump to the appropriate (16-bit)
    native mode interrupt vector. The native mode <code>BRK</code>
    vector is at <code>$00FFE6</code> and the native mode
    <code>COP</code> vector is at <code>$00FFE4</code>.</p>
    <p>In emulation mode, <code>BRK</code> and <code>COP</code>
    push the 16-bit address (again high byte first, then low byte)
    of the <code>BRK</code> or <code>COP</code> instruction plus 2,
    then push the P register, then jump to the appropriate (16-bit)
    emulation mode interrupt vector. The emulation mode
    <code>BRK</code> vector is at <code>$00FFFE</code> and the
    emulation mode <code>COP</code> vector is at
    <code>$00FFF4</code>. When <code>BRK</code> pushes the P
    register, the b flag (i.e. bit 5) will be set; because, in
    emulation mode, as on the NMOS 6502 and 65C02, <code>BRK</code>
    and <code>IRQ</code> share an interrupt vector, this allows the
    <code>BRK</code>/<code>IRQ</code> handler to distinguish a
    <code>BRK</code> from an <code>IRQ</code>. <code>COP</code> in
    emulation mode may seem somewhat paradoxical, since it was not
    available on the NMOS 6502 or 65C02, but <code>COP</code> can
    be used in emulation mode, and when pushing onto the stack it
    will wrap at the page 1 boundary (in other words, it is treated
    as an "old" instruction, rather than a "new" instruction).</p>
    <ul>
      <li>The I Flag Is Set After Pushing The P Register;
      Furthermore, Like The 65C02 (But Unlike The Nmos 6502), The D
      Flag Is Cleared After Pushing The P Register, Thus Ensuring
      That The D Flag Has A Known Value (I.E. Zero) For Brk and Cop
      Handlers.</li>
    </ul>
    <p>An important note: as on the NMOS 6502 and 65C02, the
    correct way for an emulation mode
    <code>BRK</code>/<code>IRQ</code> handler to distinguish a
    <code>BRK</code> from an <code>IRQ</code> is to use the stacked
    value of the b flag (i.e. bit 5 of the stacked value of the P
    register). Thus, this is correct (assuming that 2,S is within
    page 1; i.e. that S &lt; <code>$01FE</code>, which is usually
    the case):</p>
    <pre>
EMULATION_BRKIRQ_HANDLER
   PHA
   LDA 2,S
   BIT #$10
   BNE BRK
   BEQ IRQ
</pre>
    <p class="added">but this is incorrect (since it uses the
    current, rather than the stacked value of the P register):</p>
    <pre>
EMULATION_BRKIRQ_HANDLER
   PHA
   PHP
   PLA
   BIT #$10
   BNE BRK
   BEQ IRQ
</pre>
    <p>Also, there are several ramifications of <code>BRK</code>
    and <code>COP</code> to keep in mind. First, the fact that both
    <code>BRK</code> and <code>COP</code> push the address of the
    <code>BRK</code> or <code>COP</code> instruction plus 2 means
    that <code>RTI</code> will return to the address of the
    <code>BRK</code> or <code>COP</code> instruction plus 2; thus,
    both instructions have a signature byte (even though neither
    instruction makes any use of this signature byte) which is
    skipped. Since most NMOS 6502 and 65C02 assemblers will
    assemble a <code>BRK</code> instruction as a one byte
    instruction (i.e. the opcode <code>$00</code>) rather than a
    two byte instruction (i.e. the opcode <code>$00</code> and the
    signature byte), most 65C816 assemblers will also assemble a
    <code>BRK</code> instruction as a one byte instruction rather
    than a two byte instruction; despite this, on all members of
    the 6502 family, the <code>BRK</code> instruction is really a
    two byte instruction, consisting of an opcode
    (<code>$00</code>) and a signature byte.</p>
    <p>Second, the fact that all interrupt vectors are 16-bit
    addresses (rather than 24-bit addresses) means that the
    interrupt handlers must be located in bank 0 (or at least begin
    in bank 0, since it's possible to use <code>JMP</code> or
    <code>JSL</code> to execute code in another bank).</p>
    <p>Third, because emulation mode pushes a 16-bit address, a
    <code>BRK</code> or <code>COP</code> must be executed from bank
    0 in emulation mode; the interrupt handler has no way of
    determining which bank to return to, since the program bank is
    not pushed. Furthermore, the handler must return from bank 0
    (i.e. the <code>RTI</code> instruction of the handler must be
    located in bank 0) since <code>RTI</code> (in emulation mode)
    will pull a 16-bit address, rather than a 24-bit address.
    (Actually, there is a way to use <code>BRK</code> and
    <code>COP</code> in emulation mode from a nonzero bank: if the
    <code>BRK</code> or <code>COP</code> is preceded by a
    <code>PHK</code>, then <code>PLP</code> <code>RTL</code> can be
    used to instead of <code>RTI</code> to return from the
    interrupt handler. However, because <code>RTL</code> increments
    the program counter after pulling it from the stack, this will
    return to the address of the <code>BRK</code> or
    <code>COP</code> instruction plus 3; in effect, this behaves as
    though <code>BRK</code> and <code>COP</code> had 2 signature
    bytes rather than 1 signature byte. Note that most
    <code>BRK</code> and <code>COP</code> handlers do not make use
    of this technique.)</p>
    <p>Fourth, because <code>RTI</code> pulls the K register in
    native mode, but not in emulation mode (essentially, it pulls a
    24-bit address in the native mode, but a 16-bit address in
    emulation mode), it is vitally important that a native mode
    handler returns in native mode and an emulation mode handler
    returns in emulation mode. Generally, the handler itself would
    not need to switch modes, but if it calls a subroutine that
    executes in the other mode, it is important to ensure that the
    65C816 is switched back into the original mode before returning
    from the handler.</p>
    <p>Example: If the S register is <code>$01FF</code>, the e flag
    is 0, the P register is <code>$08</code>, and</p>
    <ul>
      <li><code>$00Ffe6</code> Contains <code>$Ab</code></li>
      <li><code>$00Ffe7</code> Contains <code>$Cd</code></li>
    </ul>
    <p class="added">then a <code>BRK</code> at
    <code>$123456</code></p>
    <ul>
      <li>Stores <code>$12</code> At <code>$0001Ff</code></li>
      <li>Stores <code>$34</code> At <code>$0001Fe</code></li>
      <li>Stores <code>$58</code> At <code>$0001Fd</code></li>
      <li>Stores <code>$08</code> At <code>$0001Fc</code></li>
    </ul>
    <p class="added">then jumps to <code>$00CDAB</code>, and</p>
    <ul>
      <li>The S Register Will Be <code>$01Fb</code></li>
      <li>The D Flag Will Be 0</li>
      <li>The I Flag Will Be 1</li>
    </ul>
  </section>
  <section>
    <h3><a id="6.3.1.1" name="6.3.1.1">6.3.1.1 Hardware
    Interrupts</a></h3>
    <p>In addition to the two software interrupts (<code>BRK</code>
    and <code>COP</code>), the 65C816 has four hardware interrupts:
    ABORT, <code>IRQ</code>, <code>NMI</code>, and RESET. While the
    hardware interrupts are not instructions, they function in much
    the same way as the software interrupt instructions.</p>
    <p>In native mode, the K register (i.e. program bank register)
    is pushed, then the 16-bit program counter is pushed (again
    high byte first, then low byte), then the P register is pushed,
    and finally, the 65C816 jumps to the appropriate (16-bit)
    native mode interrupt vector.</p>
    <p>In emulation mode, the 16-bit program counter is pushed
    (again high byte first, then low byte), then the P register is
    pushed, and finally, the 65C816 jumps to the appropriate
    (16-bit) emulation mode interrupt vector. ABORT (like
    <code>COP</code>) in emulation mode may seem somewhat
    paradoxical, since there is no ABORTB pin on the NMOS 6502 or
    65C02, but when an ABORT interrupt occurs in emulation mode,
    (again, like <code>COP</code>) when pushing onto the stack it
    will wrap at the page 1 boundary (in other words, it is treated
    as an "old" hardware interrupt, rather than a "new" one).</p>
    <p>The interrupt vectors for native (e flag = 0) and emulation
    mode (e flag = 1) are:</p>
    <table class="opcode">
      <thead>
        <tr>
          <th>e = 0</th>
          <th>e = 1</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>00FFE4</td>
          <td>00FFF4 COP</td>
        </tr>
        <tr>
          <td>00FFE6</td>
          <td>00FFFE BRK</td>
        </tr>
        <tr>
          <td>00FFE8</td>
          <td>00FFF8 ABORT</td>
        </tr>
        <tr>
          <td>00FFEA</td>
          <td>00FFFA NMI</td>
        </tr>
        <tr>
          <td></td>
          <td>00FFFC RESET</td>
        </tr>
        <tr>
          <td>00FFEE</td>
          <td>00FFFE IRQ</td>
        </tr>
      </tbody>
    </table>
    <p>The address decoding circuitry can use the <code>VPB</code>
    signal to tell the 65C816 to fetch any or all of these
    interrupt vectors from any address desired. A RESET interrupt
    puts the 65C816 into emulation mode, thus there is no native
    mode RESET vector. Again, note that, as on the NMOS 6502 and
    65C02, <code>BRK</code> and <code>IRQ</code> share an interrupt
    vector, and the correct way for the interrupt handler to
    distinguish them is to use the stacked (rather than the
    current) value of the b flag.</p>
    <p>As with the software interrupts, the i flag is set after
    pushing the P register; furthermore, like the 65C02 (but unlike
    the NMOS 6502), the d flag is cleared after pushing the P
    register, thus ensuring that the d flag has a known value (i.e.
    zero) for interrupt handlers.</p>
    <p>If an <code>IRQ</code> or <code>NMI</code> occurs in the
    middle of an instruction (e.g. after the first cycle of a
    <code>BCC</code> instruction), then the instruction is
    completed before pushing anything and jumping to the interrupt
    vector. For ABORT and RESET, the instruction is not completed
    (in the former case, the instruction is aborted, and then
    restarted when the interrupt handler returns).</p>
    <p>Also, the ramifications of the software interrupts
    (described in the previous section) also apply to hardware
    interrupts; namely, that (a) the interrupt handler must be
    located in bank 0 (because the interrupt vectors are 16-bit
    addresses), (b) in emulation mode, if an interrupt were to
    occur while executing code in a nonzero bank, (because the
    program bank register is not pushed) an <code>RTI</code>
    instruction has no way of knowing what bank to return to (this
    is far more important for hardware interrupts, since in
    general, there is no way know when they'll occur, and
    furthermore, an <code>NMI</code> cannot be masked by the i
    flag, thus the technique of preceding a <code>BRK</code> or
    <code>COP</code> by a <code>PHK</code> does not apply to
    hardware interrupts), and (c) an interrupt must be in the same
    mode (native or emulation) it started in when returning via an
    <code>RTI</code> instruction.</p>
    <p>Example: If the S register is <code>$01FF</code>, the e flag
    is 0, the P register is <code>$08</code>, and</p>
    <ul>
      <li><code>$00Ffe6</code> Contains <code>$Ab</code></li>
      <li><code>$00Ffe7</code> Contains <code>$Cd</code></li>
    </ul>
    <p class="added">and an <code>NMI</code> occurs after the first
    cycle of a <code>LDA</code> <code>#$1122</code> instruction at
    <code>$345678</code>, then the <code>LDA</code> instruction
    will be completed, then</p>
    <ul>
      <li><code>$34</code> Will Be Stored At
      <code>$0001Ff</code></li>
      <li><code>$56</code> Will Be Stored At
      <code>$0001Fe</code></li>
      <li><code>$7B</code> Will Be Stored At
      <code>$0001Fd</code></li>
      <li><code>$08</code> Will Be Stored At
      <code>$0001Fc</code></li>
    </ul>
    <p class="added">then the 65C816 will jump to
    <code>$00CDAB</code>; afterwards</p>
    <ul>
      <li>The S Register Will Be <code>$01Fb</code></li>
      <li>The D Flag Will Be 0</li>
      <li>The I Flag Will Be 1</li>
    </ul>
  </section>
  <section>
    <h3><a id="6.3.2" name="6.3.2">6.3.2 <code>RTI</code></a></h3>
    <pre>
ReTurn from Interrupt
</pre>
    <table class="opcode">
      <thead>
        <tr>
          <th>OP</th>
          <th>LEN</th>
          <th>CYCLES</th>
          <th>MODE</th>
          <th>nvmxdizc e</th>
          <th>SYNTAX</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>40</td>
          <td>1</td>
          <td>7-e</td>
          <td>imp</td>
          <td>******** .</td>
          <td>RTI</td>
        </tr>
      </tbody>
    </table>
    <p>In native mode, the P register is pulled, then the 16-bit
    program counter is pulled (low byte first, then high byte),
    then the K register (i.e. program bank register) is pulled.</p>
    <p>In emulation mode, the P register is pulled, then the 16-bit
    program counter is pulled (again low byte first, then high
    byte).</p>
    <p>Note that unlike <code>RTS</code> (and <code>RTL</code>),
    the program counter is not incremented after it is pulled from
    the stack.</p>
    <p>Again, as noted in the previous two sections, before
    returning from an interrupt via an <code>RTI</code>
    instruction, the mode (native or emulation) must be the same as
    it was when the interrupt occurred, since a different number of
    bytes are pulled from the stack.</p>
    <p>Example: If the S register is <code>$01FB</code>, the e flag
    is 0, and</p>
    <ul>
      <li><code>$0001Fc</code> Contains <code>$08</code></li>
      <li><code>$0001Fd</code> Contains <code>$12</code></li>
      <li><code>$0001Fe</code> Contains <code>$34</code></li>
      <li><code>$0001Ff</code> Contains <code>$56</code></li>
    </ul>
    <p class="added">then an <code>RTI</code> will jump to
    <code>$563412</code>, and</p>
    <ul>
      <li>The S Register Will Be <code>$01Ff</code></li>
      <li>The P Register Will Be <code>$08</code></li>
    </ul>
  </section>
  <section>
    <h3><a id="6.4.1" name="6.4.1">6.4.1 <code>CLC</code>
    <code>CLD</code> <code>CLI</code> <code>CLV</code>
    <code>SEC</code> <code>SED</code> <code>SEI</code></a></h3>
    <pre>
CLear Carry
CLear Decimal mode
CLear Interrupt disable
CLear oVerflow
SEt Carry
SEt Decimal mode
SEt Interrupt disable
</pre>
    <table class="opcode">
      <thead>
        <tr>
          <th>OP</th>
          <th>LEN</th>
          <th>CYCLES</th>
          <th>MODE</th>
          <th>nvmxdizc e</th>
          <th>SYNTAX</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>18</td>
          <td>1</td>
          <td>2</td>
          <td>imp</td>
          <td>.......0 .</td>
          <td>CLC</td>
        </tr>
        <tr>
          <td>D8</td>
          <td>1</td>
          <td>2</td>
          <td>imp</td>
          <td>....0... .</td>
          <td>CLD</td>
        </tr>
        <tr>
          <td>58</td>
          <td>1</td>
          <td>2</td>
          <td>imp</td>
          <td>.....0.. .</td>
          <td>CLI</td>
        </tr>
        <tr>
          <td>B8</td>
          <td>1</td>
          <td>2</td>
          <td>imp</td>
          <td>.0...... .</td>
          <td>CLV</td>
        </tr>
        <tr>
          <td>38</td>
          <td>1</td>
          <td>2</td>
          <td>imp</td>
          <td>.......1 .</td>
          <td>SEC</td>
        </tr>
        <tr>
          <td>F8</td>
          <td>1</td>
          <td>2</td>
          <td>imp</td>
          <td>....1... .</td>
          <td>SED</td>
        </tr>
        <tr>
          <td>78</td>
          <td>1</td>
          <td>2</td>
          <td>imp</td>
          <td>.....1.. .</td>
          <td>SEI</td>
        </tr>
      </tbody>
    </table>
    <p class="added"><code>CLC</code>, <code>CLD</code>,
    <code>CLI</code>, and <code>CLV</code> clear the c, d, i, and v
    flags respectively.</p>
    <p><code>SEC</code>, <code>SED</code>, and <code>SEI</code> set
    the c, d, and i flags respectively.</p>
    <p>Incidentally, you may wish to define <code>SEI</code> and
    <code>CLI</code> as macros called (e.g.) DI and EI (i.e.
    Disable Interrupt and Enable Interrupt); that way you don't
    have to remember whether i flag 0 means disable interrupts (it
    doesn't) or enable interrupts (it does).</p>
    <p>Example: after a <code>CLC</code></p>
    <ul>
      <li>The C Flag Is 0</li>
    </ul>
  </section>
  <section>
    <h3><a id="6.4.2" name="6.4.2">6.4.2 <code>REP</code>
    <code>SEP</code></a></h3>
    <pre>
REset Processor status bits
SEt Processor status bits
</pre>
    <table class="opcode">
      <thead>
        <tr>
          <th>OP</th>
          <th>LEN</th>
          <th>CYCLES</th>
          <th>MODE</th>
          <th>nvmxdizc e</th>
          <th>SYNTAX</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>C2</td>
          <td>2</td>
          <td>3</td>
          <td>imm</td>
          <td>******** .</td>
          <td>REP #$12</td>
        </tr>
        <tr>
          <td>E2</td>
          <td>2</td>
          <td>3</td>
          <td>imm</td>
          <td>******** .</td>
          <td>SEP #$12</td>
        </tr>
      </tbody>
    </table>
    <p class="added"><code>REP</code> and <code>SEP</code> reset
    (i.e. clear) and set (respectively) the bits of the P register
    that are ones in the operand; bits of the P register that are
    zero in the operand are not affected. (This is analogous to how
    <code>TRB</code> and <code>TRB</code> reset and set the bits of
    the memory location that are ones in the accumulator, and do
    not affect the bits in the memory location that are zero in the
    accumulator.)</p>
    <p>Note that when the e flag is 1, the m and x flag are forced
    to 1, so after the <code>REP</code> or <code>SEP</code>, both
    flags will still be 1 no matter what the operand is.</p>
    <p>Example: If the e flag is 0, then after <code>SEP</code>
    <code>#$21</code></p>
    <ul>
      <li>The M and C Flags Will Be 1</li>
      <li>The N, V, X, D, I, and Z Flags Will Not Be Affected</li>
    </ul>
  </section>
  <section>
    <h3><a id="6.5" name="6.5">6.5 <code>LDA</code>
    <code>LDX</code> <code>LDY</code> <code>STA</code>
    <code>STX</code> <code>STY</code> <code>STZ</code></a></h3>
    <pre>
LoaD Accumulator
LoaD X register
LoaD Y register
STore Accumulator
STore X register
STore Y register
STore Zero
</pre>
    <table class="opcode">
      <thead>
        <tr>
          <th>OP</th>
          <th>LEN</th>
          <th>CYCLES</th>
          <th>MODE</th>
          <th>nvmxdizc e</th>
          <th>SYNTAX</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>A1</td>
          <td>2</td>
          <td>7-m+w</td>
          <td>(dir,X)</td>
          <td>m.....m. .</td>
          <td>LDA ($10,X)</td>
        </tr>
        <tr>
          <td>A3</td>
          <td>2</td>
          <td>5-m</td>
          <td>stk,S</td>
          <td>m.....m. .</td>
          <td>LDA $32,S</td>
        </tr>
        <tr>
          <td>A5</td>
          <td>2</td>
          <td>4-m+w</td>
          <td>dir</td>
          <td>m.....m. .</td>
          <td>LDA $10</td>
        </tr>
        <tr>
          <td>A7</td>
          <td>2</td>
          <td>7-m+w</td>
          <td>[dir]</td>
          <td>m.....m. .</td>
          <td>LDA [$10]</td>
        </tr>
        <tr>
          <td>A9</td>
          <td>3-m</td>
          <td>3-m</td>
          <td>imm</td>
          <td>m.....m. .</td>
          <td>LDA #$54</td>
        </tr>
        <tr>
          <td>AD</td>
          <td>3</td>
          <td>5-m</td>
          <td>abs</td>
          <td>m.....m. .</td>
          <td>LDA $9876</td>
        </tr>
        <tr>
          <td>AF</td>
          <td>4</td>
          <td>6-m</td>
          <td>long</td>
          <td>m.....m. .</td>
          <td>LDA $FEDBCA</td>
        </tr>
        <tr>
          <td>B1</td>
          <td>2</td>
          <td>7-m+w-x+x*p</td>
          <td>(dir),Y</td>
          <td>m.....m. .</td>
          <td>LDA ($10),Y</td>
        </tr>
        <tr>
          <td>B2</td>
          <td>2</td>
          <td>6-m+w</td>
          <td>(dir)</td>
          <td>m.....m. .</td>
          <td>LDA ($10)</td>
        </tr>
        <tr>
          <td>B3</td>
          <td>2</td>
          <td>8-m</td>
          <td>(stk,S),Y</td>
          <td>m.....m. .</td>
          <td>LDA ($32,S),Y</td>
        </tr>
        <tr>
          <td>B5</td>
          <td>2</td>
          <td>5-m+w</td>
          <td>dir,X</td>
          <td>m.....m. .</td>
          <td>LDA $10,X</td>
        </tr>
        <tr>
          <td>B7</td>
          <td>2</td>
          <td>7-m+w</td>
          <td>[dir],Y</td>
          <td>m.....m. .</td>
          <td>LDA [$10],Y</td>
        </tr>
        <tr>
          <td>B9</td>
          <td>3</td>
          <td>6-m-x+x*p</td>
          <td>abs,Y</td>
          <td>m.....m. .</td>
          <td>LDA $9876,Y</td>
        </tr>
        <tr>
          <td>BD</td>
          <td>3</td>
          <td>6-m-x+x*p</td>
          <td>abs,X</td>
          <td>m.....m. .</td>
          <td>LDA $9876,X</td>
        </tr>
        <tr>
          <td>BF</td>
          <td>4</td>
          <td>6-m</td>
          <td>long,X</td>
          <td>m.....m. .</td>
          <td>LDA $FEDCBA,X</td>
        </tr>
        <tr>
          <td>A2</td>
          <td>3-x</td>
          <td>3-x</td>
          <td>imm</td>
          <td>x.....x. .</td>
          <td>LDX #$54</td>
        </tr>
        <tr>
          <td>A6</td>
          <td>2</td>
          <td>4-x+w</td>
          <td>dir</td>
          <td>x.....x. .</td>
          <td>LDX $10</td>
        </tr>
        <tr>
          <td>AE</td>
          <td>3</td>
          <td>5-x</td>
          <td>abs</td>
          <td>x.....x. .</td>
          <td>LDX $9876</td>
        </tr>
        <tr>
          <td>B6</td>
          <td>2</td>
          <td>5-x+w</td>
          <td>dir,Y</td>
          <td>x.....x. .</td>
          <td>LDX $10,Y</td>
        </tr>
        <tr>
          <td>BE</td>
          <td>3</td>
          <td>6-2*x+x*p</td>
          <td>abs,Y</td>
          <td>x.....x. .</td>
          <td>LDX $9876,Y</td>
        </tr>
        <tr>
          <td>A0</td>
          <td>3-x</td>
          <td>3-x</td>
          <td>imm</td>
          <td>x.....x. .</td>
          <td>LDY #$54</td>
        </tr>
        <tr>
          <td>A4</td>
          <td>2</td>
          <td>4-x+w</td>
          <td>dir</td>
          <td>x.....x. .</td>
          <td>LDY $10</td>
        </tr>
        <tr>
          <td>AC</td>
          <td>3</td>
          <td>5-x</td>
          <td>abs</td>
          <td>x.....x. .</td>
          <td>LDY $9876</td>
        </tr>
        <tr>
          <td>B4</td>
          <td>2</td>
          <td>5-x+w</td>
          <td>dir,X</td>
          <td>x.....x. .</td>
          <td>LDY $10,X</td>
        </tr>
        <tr>
          <td>BC</td>
          <td>3</td>
          <td>6-2*x+x*p</td>
          <td>abs,X</td>
          <td>x.....x. .</td>
          <td>LDY $9876,X</td>
        </tr>
        <tr>
          <td>81</td>
          <td>2</td>
          <td>7-m+w</td>
          <td>(dir,X)</td>
          <td>........ .</td>
          <td>STA ($10,X)</td>
        </tr>
        <tr>
          <td>83</td>
          <td>2</td>
          <td>5-m</td>
          <td>stk,S</td>
          <td>........ .</td>
          <td>STA $32,S</td>
        </tr>
        <tr>
          <td>85</td>
          <td>2</td>
          <td>4-m+w</td>
          <td>dir</td>
          <td>........ .</td>
          <td>STA $10</td>
        </tr>
        <tr>
          <td>87</td>
          <td>2</td>
          <td>7-m+w</td>
          <td>[dir]</td>
          <td>........ .</td>
          <td>STA [$10]</td>
        </tr>
        <tr>
          <td>8D</td>
          <td>3</td>
          <td>5-m</td>
          <td>abs</td>
          <td>........ .</td>
          <td>STA $9876</td>
        </tr>
        <tr>
          <td>8F</td>
          <td>4</td>
          <td>6-m</td>
          <td>long</td>
          <td>........ .</td>
          <td>STA $FEDBCA</td>
        </tr>
        <tr>
          <td>91</td>
          <td>2</td>
          <td>7-m+w</td>
          <td>(dir),Y</td>
          <td>........ .</td>
          <td>STA ($10),Y</td>
        </tr>
        <tr>
          <td>92</td>
          <td>2</td>
          <td>6-m+w</td>
          <td>(dir)</td>
          <td>........ .</td>
          <td>STA ($10)</td>
        </tr>
        <tr>
          <td>93</td>
          <td>2</td>
          <td>8-m</td>
          <td>(stk,S),Y</td>
          <td>........ .</td>
          <td>STA ($32,S),Y</td>
        </tr>
        <tr>
          <td>95</td>
          <td>2</td>
          <td>5-m+w</td>
          <td>dir,X</td>
          <td>........ .</td>
          <td>STA $10,X</td>
        </tr>
        <tr>
          <td>97</td>
          <td>2</td>
          <td>7-m+w</td>
          <td>[dir],Y</td>
          <td>........ .</td>
          <td>STA [$10],Y</td>
        </tr>
        <tr>
          <td>99</td>
          <td>3</td>
          <td>6-m</td>
          <td>abs,Y</td>
          <td>........ .</td>
          <td>STA $9876,Y</td>
        </tr>
        <tr>
          <td>9D</td>
          <td>3</td>
          <td>6-m</td>
          <td>abs,X</td>
          <td>........ .</td>
          <td>STA $9876,X</td>
        </tr>
        <tr>
          <td>9F</td>
          <td>4</td>
          <td>6-m</td>
          <td>long,X</td>
          <td>........ .</td>
          <td>STA $FEDCBA,X</td>
        </tr>
        <tr>
          <td>86</td>
          <td>2</td>
          <td>4-x+w</td>
          <td>dir</td>
          <td>........ .</td>
          <td>STX $10</td>
        </tr>
        <tr>
          <td>8E</td>
          <td>3</td>
          <td>5-x</td>
          <td>abs</td>
          <td>........ .</td>
          <td>STX $9876</td>
        </tr>
        <tr>
          <td>96</td>
          <td>2</td>
          <td>5-x+w</td>
          <td>dir,Y</td>
          <td>........ .</td>
          <td>STX $10,Y</td>
        </tr>
        <tr>
          <td>84</td>
          <td>2</td>
          <td>4-x+w</td>
          <td>dir</td>
          <td>........ .</td>
          <td>STY $10</td>
        </tr>
        <tr>
          <td>8C</td>
          <td>3</td>
          <td>5-x</td>
          <td>abs</td>
          <td>........ .</td>
          <td>STY $9876</td>
        </tr>
        <tr>
          <td>94</td>
          <td>2</td>
          <td>5-x+w</td>
          <td>dir,X</td>
          <td>........ .</td>
          <td>STY $10,X</td>
        </tr>
        <tr>
          <td>64</td>
          <td>2</td>
          <td>4-m+w</td>
          <td>dir</td>
          <td>........ .</td>
          <td>STZ $10</td>
        </tr>
        <tr>
          <td>74</td>
          <td>2</td>
          <td>5-m+w</td>
          <td>dir,X</td>
          <td>........ .</td>
          <td>STZ $10,X</td>
        </tr>
        <tr>
          <td>9C</td>
          <td>3</td>
          <td>5-m</td>
          <td>abs</td>
          <td>........ .</td>
          <td>STZ $9876</td>
        </tr>
        <tr>
          <td>9E</td>
          <td>3</td>
          <td>6-m</td>
          <td>abs,X</td>
          <td>........ .</td>
          <td>STZ $9876,X</td>
        </tr>
      </tbody>
    </table>
    <p class="added"><code>LDA</code>, <code>LDX</code>, and
    <code>LDY</code> load data into the accumulator, X register,
    and Y register, respectively. <code>STA</code>,
    <code>STX</code>, <code>STY</code>, <code>STZ</code> store the
    accumulator, the X register, the Y register, and zero into the
    memory location specified by the operand. Note that no
    registers are affected by <code>STZ</code>.</p>
    <p>When the m flag is 0, <code>LDA</code>, <code>STA</code>,
    and <code>STZ</code> are 16-bit operations, and when the m flag
    is 1, <code>LDA</code>, <code>STA</code>, and <code>STZ</code>
    are 8-bit operations. When the x flag is 0, <code>LDX</code>,
    <code>LDY</code>, <code>STX</code>, and <code>STY</code> are
    16-bit operations, and when the x flag is 1, <code>LDX</code>,
    <code>LDY</code>, <code>STX</code>, and <code>STY</code> are
    8-bit operations.</p>
    <p>For <code>LDA</code>, <code>LDX</code>, <code>LDY</code>,
    the n flag is 0 when the high bit of the result is 0, and 1
    when the high bit of the result is 1; the z flag is 1 when the
    result is zero, and 0 when the result is nonzero.</p>
    <p>Example: If the m flag is 0, and</p>
    <ul>
      <li><code>$123456</code> Contains <code>$Ab</code></li>
      <li><code>$123457</code> Contains <code>$Cd</code></li>
    </ul>
    <p class="added">then after a <code>LDA</code>
    <code>$123456</code></p>
    <ul>
      <li>The Accumulator Will Be <code>$Cdab</code></li>
      <li>The N Flag Will Be 1</li>
      <li>The Z Flag Will Be 0</li>
    </ul>
  </section>
  <section>
    <h3><a id="6.6" name="6.6">6.6 <code>MVN</code>
    <code>MVP</code></a></h3>
    <pre>
MoVe memory Negative
MoVe memory Positive
</pre>
    <table class="opcode">
      <thead>
        <tr>
          <th>OP</th>
          <th>LEN</th>
          <th>CYCLES</th>
          <th>MODE</th>
          <th>nvmxdizc e</th>
          <th>SYNTAX</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>54</td>
          <td>3</td>
          <td>7</td>
          <td>src,dest</td>
          <td>........ .</td>
          <td>MVN #$12,#$34</td>
        </tr>
        <tr>
          <td>44</td>
          <td>3</td>
          <td>7</td>
          <td>src,dest</td>
          <td>........ .</td>
          <td>MVP #$12,#$34</td>
        </tr>
      </tbody>
    </table>
    <p class="added"><code>MVN</code> and <code>MVP</code> move
    blocks of memory downward (i.e. from a higher (source) address
    to a lower (destination) address) and upward (i.e. from a lower
    (source) address to a higher (destination) address). The
    (16-bit) accumulator contains the number of bytes to move minus
    1, the X register contains the 16-bit source address, and the Y
    register contains the 16-bit destination address. The source
    bank and the destination bank are specified in the operand.
    Both the source and the destination address wrap at the bank
    boundary. For <code>MVN</code>, X and Y are the start (i.e.
    lowest address) of the block, but for <code>MVP</code>, X and Y
    are the end (i.e. highest address) of the block.</p>
    <p><code>MVN</code> and <code>MVP</code> decrement the (16-bit)
    accumulator and increment (for <code>MVN</code>) or decrement
    (for <code>MVP</code>) both X and Y each time a byte is moved;
    this means that the accumulator will be <code>$FFFF</code>
    after an <code>MVN</code> or <code>MVP</code> (since it
    contained the number of bytes to move minus 1) and the X and Y
    registers will be larger (for <code>MVN</code>) or smaller (for
    <code>MVP</code>) by the number of bytes moved.</p>
    <p>Also, the <code>DBR</code> is overwritten by
    <code>MVN</code> and <code>MVP</code>; after an
    <code>MVN</code> or <code>MVP</code>, the destination bank is
    stored in the <code>DBR</code>. Thus, it may be necessary in
    some instances to put a <code>PHB</code> instruction before the
    <code>MVN</code> or <code>MVP</code>, and a <code>PLB</code>
    instruction after the <code>MVN</code> or <code>MVP</code>.</p>
    <p>Each byte moved takes 7 cycles. <code>MVN</code> and
    <code>MVP</code> can be interrupted by <code>IRQ</code> and
    <code>NMI</code> before the move is complete (unlike every
    other instruction, which must finish before an <code>IRQ</code>
    or <code>NMI</code> is serviced); however, they can only be
    interrupted every seventh cycle, i.e. they cannot be
    interrupted in the middle of moving a byte, but it can be
    interrupted between moving one byte and moving the next.</p>
    <p>Another way to describe the <code>MVN</code> and
    <code>MVP</code> instruction is to say that they are 7 cycle
    instructions (sharp-eyed readers may have noticed that the
    cycle count in the table above is 7, rather than 7 times the
    number of bytes moved); after moving the byte whose (16-bit)
    source address is in the X register and whose (16-bit)
    destination address is in the Y register (and whose source and
    destination bank are specified by the operand), the destination
    bank is stored in the <code>DBR</code>, the (16-bit)
    accumulator is decremented, and both the X and Y registers are
    incremented (for <code>MVN</code>) or decremented (for
    <code>MVP</code>); then the program counter will be the address
    of the next instruction (i.e. the instruction after the
    <code>MVN</code> or <code>MVP</code>) if the accumulator is
    <code>$FFFF</code>, and the program counter will be the address
    of the the <code>MVN</code> or <code>MVP</code> if the
    accumulator is not <code>$FFFF</code> (i.e. the instruction
    jumps to itself if the accumulator is not <code>$FFFF</code>).
    Thus, the instruction is executed until A is
    <code>$FFFF</code>, both the X and Y register are incremented
    or decremented until the entire block is moved, the source and
    destination addresses wrap at bank boundaries, the instruction
    must complete all 7 cycles before an <code>IRQ</code> or
    <code>NMI</code> can only be serviced, and it will take 7
    cycles per byte moved total.</p>
    <p>An interesting question is what happens when
    <code>MVN</code> is used move upward and <code>MVP</code> is
    used to move downward. If the source and destination banks are
    different, or the source and destination blocks do not overlap,
    then the (final) result is no different than if the upward move
    had used <code>MVP</code> (and X and Y were updated to begin at
    the end of the block) or the downward move had used
    <code>MVN</code> (and, likewise, X and Y were updated to begin
    at the start of the block). However, if the source and
    destination banks are the same and the blocks do overlap,
    <code>MVN</code> and <code>MVP</code> have an interesting (and
    useful) property; they make copies of a pattern. To see how
    this works, if the accumulator is <code>$0003</code>, the X
    register is <code>$1000</code>, the Y register is
    <code>$1002</code>, and</p>
    <ul>
      <li><code>$001000</code> Contains <code>$Ab</code></li>
      <li><code>$001001</code> Contains <code>$Cd</code></li>
    </ul>
    <p class="added">then after an <code>MVN</code> #0,#0</p>
    <ul>
      <li><code>$001002</code> Will Contain <code>$Ab</code></li>
      <li><code>$001003</code> Will Contain <code>$Cd</code></li>
      <li><code>$001004</code> Will Contain <code>$Ab</code></li>
      <li><code>$001005</code> Will Contain <code>$Cd</code></li>
    </ul>
    <p>This happens because</p>
    <ul>
      <li>The Byte At <code>$001000</code> (<code>$Ab</code>) Is
      Stored At <code>$001002</code></li>
      <li>The Byte At <code>$001001</code> (<code>$Cd</code>) Is
      Stored At <code>$001003</code></li>
      <li>The Byte At <code>$001002</code> (Which Now Contains
      <code>$Ab</code>) Is Stored At <code>$001004</code></li>
      <li>The Byte At <code>$001003</code> (Which Now Contains
      <code>$Cd</code>) Is Stored At <code>$001005</code></li>
    </ul>
    <p>Incidentally, some assemblers allow an alternate syntax (in
    addition to the traditional syntax of a pair of 8-bit banks)
    where the operand is a pair of 24-bit addresses; thus, for such
    assemblers, <code>MVN</code>
    <code>#$123456</code>,<code>#$789ABC</code> is equivalent to
    <code>MVN</code> <code>#$12</code>,<code>#$78</code>.</p>
    <p>Finally, note that while <code>MVN</code> and
    <code>MVP</code> can be used when the x flag is 1 (and this
    includes the case when the e flag is 1), neither instruction is
    particularly helpful in that situation, because the high bytes
    of both the X and Y are <code>$00</code>, so both the source
    are destination blocks are confined to the first page (i.e.
    addresses <code>$0000</code> to <code>$00FF</code>) of the
    block.</p>
    <p>Example: If the accumulator is <code>$0001</code>, the X
    register is <code>$1000</code>, the Y register is
    <code>$2000</code>, and</p>
    <ul>
      <li><code>$000Fff</code> Contains <code>$Ab</code></li>
      <li><code>$001000</code> Contains <code>$Cd</code></li>
    </ul>
    <p class="added">then after an <code>MVP</code> #0,#0</p>
    <ul>
      <li>The Accumulator Will Be <code>$Ffff</code></li>
      <li>The X Register Will Be <code>$0Ffe</code></li>
      <li>The Y Register Will Be <code>$1Ffe</code></li>
      <li>The Dbr Will Be <code>$00</code></li>
      <li><code>$001Fff</code> Will Contain <code>$Ab</code></li>
      <li><code>$002000</code> Will Contain <code>$Cd</code></li>
    </ul>
  </section>
  <section>
    <h3><a id="6.7" name="6.7">6.7 <code>NOP</code>
    <code>WDM</code></a></h3>
    <pre>
No OPeration
William D. Mensch, Jr.
</pre>
    <table class="opcode">
      <thead>
        <tr>
          <th>OP</th>
          <th>LEN</th>
          <th>CYCLES</th>
          <th>MODE</th>
          <th>nvmxdizc e</th>
          <th>SYNTAX</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>EA</td>
          <td>1</td>
          <td>2</td>
          <td>imp</td>
          <td>........ .</td>
          <td>NOP</td>
        </tr>
        <tr>
          <td>42</td>
          <td>2</td>
          <td>2</td>
          <td>imm</td>
          <td>........ .</td>
          <td>WDM</td>
        </tr>
      </tbody>
    </table>
    <p class="added"><code>NOP</code>, as its name implies,
    performs no operation (affecting no flags or registers); it is
    primarily useful for (a) delaying 2 cycles when a routine
    requires exact, or special, timing, (b) disabling code via
    patch, or (c) reserving space for self-modifying code.</p>
    <p><code>WDM</code> are the initials of William D. Mensch, Jr,
    the designer of the 65C816 (and the 65C02). This opcode is
    reserved for future expansion. On the 65C816, it is acts like a
    2-byte, 2-cycle <code>NOP</code> (note that the actual
    <code>NOP</code> instruction is only 1 byte). The second byte
    is read, but ignored. This can be used to skip 1-byte
    instructions.</p>
    <p>Example: when entering</p>
    <pre>
LABEL1 INX
       DB  $42 ;WDM opcode
LABEL2 DEX
</pre>
    <p class="added">at LABEL1, the X register will be incremented
    and the <code>DEX</code> will not be executed, because the
    <code>WDM</code> opcode (<code>$42</code>) will treat it as
    immediate data and ignore it. (The X register will be
    decremented when entering at LABEL2.)</p>
  </section>
  <section>
    <h3><a id="6.8.1" name="6.8.1">6.8.1 <code>PEA</code>
    <code>PEI</code> <code>PER</code></a></h3>
    <pre>
Push Effective Address
Push Effective Indirect address
Push Effective Relative address
</pre>
    <table class="opcode">
      <thead>
        <tr>
          <th>OP</th>
          <th>LEN</th>
          <th>CYCLES</th>
          <th>MODE</th>
          <th>nvmxdizc e</th>
          <th>SYNTAX</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>F4</td>
          <td>3</td>
          <td>5</td>
          <td>imm</td>
          <td>........ .</td>
          <td>PEA #$1234</td>
        </tr>
        <tr>
          <td>D4</td>
          <td>2</td>
          <td>6+w</td>
          <td>dir</td>
          <td>........ .</td>
          <td>PEI $12</td>
        </tr>
        <tr>
          <td>62</td>
          <td>3</td>
          <td>6</td>
          <td>imm</td>
          <td>........ .</td>
          <td>PER LABEL</td>
        </tr>
      </tbody>
    </table>
    <p class="added"><code>PEA</code>, <code>PEI</code>, and
    <code>PER</code> all push a 16-bit value onto the stack. In
    fact, they could be thought of as the different addressing
    modes of the same instruction, since the operation is otherwise
    the same. This is analogous to there being different
    instruction names for <code>JMP</code> absolute and
    <code>BRL</code>, which are really the same operation, it's
    just that there is no assembler syntax to differentiate
    absolute from relative addressing, hence the different
    names.</p>
    <p>Note, however, that the names of these instructions are a
    bit misleading. The 16-bit value that is pushed onto the stack
    need not be an address; it could be a constant. Because of the
    names, the operand syntax permitted (or required) can vary from
    assembler to assembler.</p>
    <p><code>PEA</code> <code>#$1234</code> is the syntax that is
    most consistent with the operation of the instruction, since it
    simply pushes the value <code>$1234</code>, but does not access
    memory location <code>$1234</code> (in any bank). This is
    analogous to <code>LDA</code> <code>#$1234</code> vs.
    <code>LDA</code> <code>$1234</code>; the former does not access
    memory location <code>$1234</code> (in any bank), but the
    latter does (in some bank). Nonetheless, some assemblers permit
    (or require) the syntax <code>PEA</code>
    <code>$1234</code>.</p>
    <p>Likewise, <code>PEI</code> <code>$12</code> is the syntax
    that is most consistent with the operation of the instruction.
    It pushes the same 16-bit value that (assuming the m flag is 0)
    <code>LDA</code> <code>$12</code> loads into the accumulator,
    rather that the value that <code>LDA ($12)</code> loads into
    the accumulator. Nonetheless, some assemblers permit (or
    require) the syntax <code>PEI ($12)</code>. Note, however, that
    <code>PEI</code> always pushes a 16-bit value no matter what
    the value of the m flag (or, for that matter the x flag)
    is.</p>
    <p>Most assemblers use the syntax <code>PER</code> LABEL,
    rather than <code>PER</code> #LABEL; in fact, assemblers that
    even permit the latter syntax (much less require it) are rare.
    Even though <code>PER</code> <code>$1234</code> itself does not
    access memory location <code>$1234</code>, subsequent
    instructions in any program that uses <code>PER</code> are
    likely to use the value pushed to access that memory location
    shortly thereafter. For example</p>
    <pre>
       PER LABEL2-1
       BRL LABEL1
LABEL2
</pre>
    <p class="added">is like a <code>JSR</code> LABEL1 but with
    relative (instead of absolute) addressing. <code>PER</code>
    doesn't access address LABEL2, but address LABEL2 gets accessed
    when the subroutine returns and the opcode at LABEL2 is
    fetched. A (somewhat) comparable situation is <code>JMP</code>
    <code>$1234</code>; the <code>JMP</code> itself does not access
    <code>$1234</code>, but <code>$1234</code> is accessed when the
    opcode at <code>$1234</code> (i.e. the next instruction) is
    fetched.</p>
    <p>Example: If the S register is <code>$01FF</code>, then after
    <code>PEA</code> <code>#$1234</code>,</p>
    <ul>
      <li><code>$0001Ff</code> Will Contain <code>$12</code></li>
      <li><code>$0001Fe</code> Will Contain <code>$34</code></li>
      <li>The S Register Will Be <code>$01Fd</code></li>
    </ul>
  </section>
  <section>
    <h3><a id="6.8.2" name="6.8.2">6.8.2 <code>PHA</code>
    <code>PHX</code> <code>PHY</code> <code>PLA</code>
    <code>PLX</code> <code>PLY</code></a></h3>
    <pre>
PusH Accumulator
PusH X register
PusH Y register
PulL Accumulator
PulL X register
PulL Y register
</pre>
    <table class="opcode">
      <thead>
        <tr>
          <th>OP</th>
          <th>LEN</th>
          <th>CYCLES</th>
          <th>MODE</th>
          <th>nvmxdizc e</th>
          <th>SYNTAX</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>48</td>
          <td>1</td>
          <td>4-m</td>
          <td>imp</td>
          <td>........ .</td>
          <td>PHA</td>
        </tr>
        <tr>
          <td>DA</td>
          <td>1</td>
          <td>4-x</td>
          <td>imp</td>
          <td>........ .</td>
          <td>PHX</td>
        </tr>
        <tr>
          <td>5A</td>
          <td>1</td>
          <td>4-x</td>
          <td>imp</td>
          <td>........ .</td>
          <td>PHY</td>
        </tr>
        <tr>
          <td>68</td>
          <td>1</td>
          <td>5-m</td>
          <td>imp</td>
          <td>m.....m. .</td>
          <td>PLA</td>
        </tr>
        <tr>
          <td>FA</td>
          <td>1</td>
          <td>5-x</td>
          <td>imp</td>
          <td>x.....x. .</td>
          <td>PLX</td>
        </tr>
        <tr>
          <td>7A</td>
          <td>1</td>
          <td>5-x</td>
          <td>imp</td>
          <td>x.....x. .</td>
          <td>PLY</td>
        </tr>
      </tbody>
    </table>
    <p class="added"><code>PHA</code>, <code>PHX</code>, and
    <code>PHY</code> push the accumulator, X register, and Y
    register, respectively, onto the stack. <code>PLA</code>,
    <code>PLX</code>, and <code>PLY</code> pull the accumulator, X
    register, and Y register, respectively, from the stack.</p>
    <p>When the m flag is 0, <code>PHA</code> and <code>PLA</code>
    push and pull a 16-bit value, and when the m flag is 1,
    <code>PHA</code> and <code>PLA</code> push and pull an 8-bit
    value.</p>
    <p>When the x flag is 0, <code>PHX</code>, <code>PHY</code>,
    <code>PLX</code>, and <code>PLY</code> push and pull a 16-bit
    value, and when the x flag is 1, <code>PHX</code>,
    <code>PHY</code>, <code>PLX</code>, and <code>PLY</code> push
    and pull an 8-bit value.</p>
    <p>For <code>PLA</code>, <code>PLX</code>, and
    <code>PLY</code>, the n flag is 1 if the high bit of the result
    (pulled into the register) is 1, and the n flag is 0 when the
    high bit of the result is 0; the z flag is 1 if the result is
    zero, and the z flag is 0 if the result is nonzero.</p>
    <p>Example: If the S register is <code>$01FD</code>, the m flag
    is 0, and</p>
    <ul>
      <li><code>$0001Fe</code> Contains <code>$Ab</code></li>
      <li><code>$0001Ff</code> Contains <code>$Cd</code></li>
    </ul>
    <p class="added">then after a <code>PLA</code></p>
    <ul>
      <li>The Accumulator Will Be <code>$Cdab</code></li>
      <li>The N Flag Will Be 1</li>
      <li>The Z Flag Will Be 0</li>
      <li>The S Register Will Be <code>$01Ff</code></li>
    </ul>
  </section>
  <section>
    <h3><a id="6.8.3" name="6.8.3">6.8.3 <code>PHB</code>
    <code>PHD</code> <code>PHK</code> <code>PHP</code>
    <code>PLB</code> <code>PLD</code> <code>PLP</code></a></h3>
    <pre>
PusH data Bank register
PusH Direct register
PusH K register
PusH Processor status register
PulL data Bank register
PulL Direct register
PulL Processor status register
</pre>
    <table class="opcode">
      <thead>
        <tr>
          <th>OP</th>
          <th>LEN</th>
          <th>CYCLES</th>
          <th>MODE</th>
          <th>nvmxdizc e</th>
          <th>SYNTAX</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>8B</td>
          <td>1</td>
          <td>3</td>
          <td>imp</td>
          <td>........ .</td>
          <td>PHB</td>
        </tr>
        <tr>
          <td>0B</td>
          <td>1</td>
          <td>4</td>
          <td>imp</td>
          <td>........ .</td>
          <td>PHD</td>
        </tr>
        <tr>
          <td>4B</td>
          <td>1</td>
          <td>3</td>
          <td>imp</td>
          <td>........ .</td>
          <td>PHK</td>
        </tr>
        <tr>
          <td>08</td>
          <td>1</td>
          <td>3</td>
          <td>imp</td>
          <td>........ .</td>
          <td>PHP</td>
        </tr>
        <tr>
          <td>AB</td>
          <td>1</td>
          <td>4</td>
          <td>imp</td>
          <td>*.....*. .</td>
          <td>PLB</td>
        </tr>
        <tr>
          <td>2B</td>
          <td>1</td>
          <td>5</td>
          <td>imp</td>
          <td>*.....*. .</td>
          <td>PLD</td>
        </tr>
        <tr>
          <td>28</td>
          <td>1</td>
          <td>4</td>
          <td>imp</td>
          <td>******** .</td>
          <td>PLP</td>
        </tr>
      </tbody>
    </table>
    <p class="added"><code>PHB</code>, <code>PHD</code>,
    <code>PHK</code>, and <code>PHP</code> push the
    <code>DBR</code>, the D register, the K register, and the P
    register, respectively, onto the stack. <code>PLB</code>,
    <code>PLD</code>, and <code>PLP</code> pull the
    <code>DBR</code>, the D register, and the P register,
    respectively, from the stack.</p>
    <p><code>PHP</code>, <code>PHK</code>, <code>PHP</code>,
    <code>PLB</code>, and <code>PLP</code> push and pull one byte
    from the stack; <code>PHD</code> and <code>PLD</code> push and
    pull two bytes from the stack.</p>
    <p>For <code>PLB</code> and <code>PLD</code>, the n flag is 1
    when the high bit of the result (i.e. the value pulled into the
    register) is 1, and the n flag is 0 when high bit of the result
    is 0; the z flag is 1 when the result is zero, and the z flag
    is 0 when the result is nonzero.</p>
    <p>For <code>PLP</code>, (all of) the flags are pulled from the
    stack. Note that when the e flag is 1, the m and x flag are
    forced to 1, so after the <code>PLP</code>, both flags will
    still be 1 no matter what value is pulled from the stack.</p>
    <p>Incidentally, note that the only way to change the value of
    the <code>DBR</code> without moving memory (with
    <code>MVN</code> or <code>MVP</code>) is the <code>PLB</code>
    instruction; there are no load or transfer instructions that
    change the <code>DBR</code>.</p>
    <p>Example: If the S register is <code>$01FD</code> and</p>
    <ul>
      <li><code>$0001Fe</code> Contains <code>$Ab</code></li>
      <li><code>$0001Ff</code> Contains <code>$Cd</code></li>
    </ul>
    <p class="added">then after a <code>PLD</code></p>
    <ul>
      <li>The D Register Will Be <code>$Cdab</code></li>
      <li>The N Flag Will Be 1</li>
      <li>The Z Flag Will Be 0</li>
      <li>The S Register Will Be <code>$01Ff</code></li>
    </ul>
  </section>
  <section>
    <h3><a id="6.9" name="6.9">6.9 <code>STP</code>
    <code>WAI</code></a></h3>
    <pre>
SToP the clock
WAit for Interrupt
</pre>
    <table class="opcode">
      <thead>
        <tr>
          <th>OP</th>
          <th>LEN</th>
          <th>CYCLES</th>
          <th>MODE</th>
          <th>nvmxdizc e</th>
          <th>SYNTAX</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>DB</td>
          <td>1</td>
          <td>3</td>
          <td>imp</td>
          <td>........ .</td>
          <td>STP</td>
        </tr>
        <tr>
          <td>CB</td>
          <td>1</td>
          <td>3</td>
          <td>imp</td>
          <td>........ .</td>
          <td>WAI</td>
        </tr>
      </tbody>
    </table>
    <p class="added"><code>STP</code> stops the clock input of the
    65C816, effectively shutting down the 65C816 until a hardware
    reset (interrupt) occurs. This puts the 65C816 into a low power
    state. This is useful for applications (circuits) that require
    low power consumption, but <code>STP</code> is rarely seen
    otherwise.</p>
    <p><code>WAI</code> puts the 65C816 into a low power sleep
    state until a hardware interrupt occurs. In addition to
    reducing power consumption, using <code>WAI</code> also ensures
    that the interrupt will be recognized immediately. In other
    words, if an interrupt (e.g. an <code>NMI</code>) occurs in the
    middle of an instruction (e.g. <code>ADC</code>), the
    instruction must finish before the interrupt will be recognized
    (i.e. before jumping to the interrupt vector). When
    <code>WAI</code> is used, once its third cycle is complete, the
    65C816 will wait for the interrupt and can respond to it
    without any additional delay whenever it occurs.</p>
    <p>When the i flag is 1, interrupts are disabled, and normally
    an <code>IRQ</code> would be ignored. However, <code>WAI</code>
    when the i flag is 1 is a special case; specifically, when an
    <code>IRQ</code> occurs (after the <code>WAI</code>
    instruction), the 65C816 will continue with the next
    instruction rather than jumping to the interrupt vector. This
    means an <code>IRQ</code> can be responded to within one cycle.
    The interrupt handler is effectively inline code, rather than a
    separate routine, and thus it does not end with an
    <code>RTI</code>, resulting in fewer cycles needed to handle
    the interrupt.</p>
  </section>
  <section>
    <h3><a id="6.10.1" name="6.10.1">6.10.1 <code>TAX</code>
    <code>TAY</code> <code>TSX</code> <code>TXA</code>
    <code>TXS</code> <code>TXY</code> <code>TYA</code>
    <code>TYX</code></a></h3>
    <pre>
Transfer Accumulator to X register
Transfer Accumulator to Y register
Transfer Stack pointer to X register
Transfer X register to Accumulator
Transfer X register to Stack pointer
Transfer X register to Y register
Transfer Y register to Accumulator
Transfer Y register to X register
</pre>
    <table class="opcode">
      <thead>
        <tr>
          <th>OP</th>
          <th>LEN</th>
          <th>CYCLES</th>
          <th>MODE</th>
          <th>nvmxdizc e</th>
          <th>SYNTAX</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>AA</td>
          <td>1</td>
          <td>2</td>
          <td>imp</td>
          <td>x.....x. .</td>
          <td>TAX</td>
        </tr>
        <tr>
          <td>A8</td>
          <td>1</td>
          <td>2</td>
          <td>imp</td>
          <td>x.....x. .</td>
          <td>TAY</td>
        </tr>
        <tr>
          <td>BA</td>
          <td>1</td>
          <td>2</td>
          <td>imp</td>
          <td>x.....x. .</td>
          <td>TSX</td>
        </tr>
        <tr>
          <td>8A</td>
          <td>1</td>
          <td>2</td>
          <td>imp</td>
          <td>m.....m. .</td>
          <td>TXA</td>
        </tr>
        <tr>
          <td>9A</td>
          <td>1</td>
          <td>2</td>
          <td>imp</td>
          <td>........ .</td>
          <td>TXS</td>
        </tr>
        <tr>
          <td>9B</td>
          <td>1</td>
          <td>2</td>
          <td>imp</td>
          <td>x.....x. .</td>
          <td>TXY</td>
        </tr>
        <tr>
          <td>98</td>
          <td>1</td>
          <td>2</td>
          <td>imp</td>
          <td>m.....m. .</td>
          <td>TYA</td>
        </tr>
        <tr>
          <td>BB</td>
          <td>1</td>
          <td>2</td>
          <td>imp</td>
          <td>x.....x. .</td>
          <td>TYX</td>
        </tr>
      </tbody>
    </table>
    <p class="added"><code>TAX</code>, <code>TAY</code>,
    <code>TSX</code>, <code>TXA</code>, <code>TXS</code>,
    <code>TXY</code>, <code>TYA</code>, and <code>TYX</code>
    transfer (i.e. copy) the contents from one register to another.
    The second letter of the instruction is the register
    transferred from, and the third letter of the instruction is
    the register transferred to; so (e.g.) <code>TXY</code>
    transfers the contents of the X register to the Y register.</p>
    <p>The size of the destination register (i.e. the register
    transferred to) determines whether these instructions are 8-bit
    operations or 16-bit operations. When the destination register
    is 8 bits wide, 8 bits are transferred, and when the
    destination register is 16 bits wide, 16 bits are
    transferred.</p>
    <p>The width of the accumulator is based on the m flag, and the
    width of the X and Y registers is based on the x flag, but the
    S register is always considered 16 bits wide. However, when the
    e flag is 1, SH is forced to <code>$01</code>, so in effect,
    <code>TXS</code> is an 8-bit transfer in this case since XL is
    transferred to SL and SH remains <code>$01</code>. Note that
    when the e flag is 0 and the x flag is 1 (i.e. 8-bit native
    mode), that XH is forced to zero, so after a <code>TXS</code>,
    SH will be <code>$00</code>, rather than <code>$01</code>. This
    is an important difference that must be accounted for if you
    want to run emulation mode code in (8-bit) native mode.</p>
    <ul>
      <li>The N Flag Is 1 When The High Bit Of The Result (I.E. The
      Value Transferred From One Register To The Other) Is 1, and
      The N Flag Is 0 When The High Bit Of The Result Is 0.</li>
      <li>The Z Flag Is 1 When The Result Is Zero, and The Z Flag
      Is 0 When The Result Is Nonzero.</li>
    </ul>
    <p>Example: If the accumulator is <code>$1234</code>, the X
    register is <code>$ABCD</code>, and the m flag is 1, then after
    a <code>TXA</code></p>
    <ul>
      <li>The Accumulator Will Be <code>$12Cd</code></li>
      <li>The N Flag Will Be 1 (Since Only <code>$Cd</code> Was
      Actually Transferred)</li>
      <li>The Z Flag Will Be 0</li>
    </ul>
  </section>
  <section>
    <h3><a id="6.10.2" name="6.10.2">6.10.2 <code>TCD</code>
    <code>TCS</code> <code>TDC</code> <code>TSC</code></a></h3>
    <pre>
Transfer C accumulator to Direct register
Transfer C accumulator to Stack pointer
Transfer Direct register to C accumulator
Transfer Stack pointer to C accumulator
</pre>
    <table class="opcode">
      <thead>
        <tr>
          <th>OP</th>
          <th>LEN</th>
          <th>CYCLES</th>
          <th>MODE</th>
          <th>nvmxdizc e</th>
          <th>SYNTAX</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>5B</td>
          <td>1</td>
          <td>2</td>
          <td>imp</td>
          <td>*.....*. .</td>
          <td>TCD</td>
        </tr>
        <tr>
          <td>1B</td>
          <td>1</td>
          <td>2</td>
          <td>imp</td>
          <td>........ .</td>
          <td>TCS</td>
        </tr>
        <tr>
          <td>7B</td>
          <td>1</td>
          <td>2</td>
          <td>imp</td>
          <td>*.....*. .</td>
          <td>TDC</td>
        </tr>
        <tr>
          <td>3B</td>
          <td>1</td>
          <td>2</td>
          <td>imp</td>
          <td>*.....*. .</td>
          <td>TSC</td>
        </tr>
      </tbody>
    </table>
    <p class="added"><code>TCD</code>, <code>TCS</code>,
    <code>TDC</code>, and <code>TSC</code> transfer the C
    accumulator (the full 16-bit accumulator) to and from the D and
    S registers. These instructions always transfer 16 bits, no
    matter what the value of the m flag is. However, when the e
    flag is 1, SH is forced to <code>$01</code>, so in that case,
    <code>TCS</code> acts like an 8-bit transfer, by transferring
    the A accumulator (i.e. the low byte of the accumulator) to the
    SL register.</p>
    <ul>
      <li>The N Flag Is 1 When The High Bit Of The Result (I.E. The
      Value Transferred From One Register To The Other) Is 1, and
      The N Flag Is 0 When The High Bit Of The Result Is 0.</li>
      <li>The Z Flag Is 1 When The Result Is Zero, and The Z Flag
      Is 0 When The Result Is Nonzero.</li>
    </ul>
    <p class="added"><code>TAD</code>, <code>TAS</code>,
    <code>TDA</code>, and <code>TSA</code> are alternate names for
    these instructions, and are allowed by many 65C816 assemblers.
    Note that the "C" names are somewhat more accurate names than
    the "A" names, since these instructions are always 16-bit
    operations, while other instruction names where A refers to the
    accumulator (e.g. <code>PHA</code>) are 8-bit operations or
    16-bit operations, depending on the value of the m flag.</p>
    <p>Example: If the D register is <code>$1234</code>, then after
    a <code>TDC</code></p>
    <ul>
      <li>The Accumulator Will Be <code>$1234</code></li>
      <li>The N Flag Will Be 0</li>
      <li>The Z Flag Will Be 0</li>
    </ul>
  </section>
  <section>
    <h3><a id="6.10.3" name="6.10.3">6.10.3
    <code>XBA</code></a></h3>
    <pre>
eXchange B and A accumulator
</pre>
    <table class="opcode">
      <thead>
        <tr>
          <th>OP</th>
          <th>LEN</th>
          <th>CYCLES</th>
          <th>MODE</th>
          <th>nvmxdizc e</th>
          <th>SYNTAX</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>EB</td>
          <td>1</td>
          <td>3</td>
          <td>imp</td>
          <td>*.....*. .</td>
          <td>XBA</td>
        </tr>
      </tbody>
    </table>
    <p class="added"><code>XBA</code> exchanges the B accumulator
    and the A accumulator, i.e. it swaps the high byte and the low
    byte of the accumulator. Note that this is a swap rather than a
    copy (as is the case for the transfer instructions).</p>
    <p>The n and z flags are always based on an 8-bit result, no
    matter what the value of the m flag is. Specifically, they are
    based on the A accumulator (i.e. the low byte of the
    accumulator) result; in other words, the final value of the A
    accumulator, which is the same as the initial value of the B
    accumulator.</p>
    <ul>
      <li>The N Flag Is 1 When The High Bit Of The Result Is 1, and
      The N Flag Is 0 When The High Bit Of The Result Is 0.</li>
      <li>The Z Flag Is 1 When The Result Is Zero, and The Z Flag
      Is 0 When The Result Is Nonzero.</li>
    </ul>
    <p class="added"><code>SWA</code> is an alternate name for this
    instruction, and is allowed by many 65C816 assemblers.</p>
    <p>Example: If the accumulator is <code>$6789</code>, then
    after an <code>XBA</code></p>
    <ul>
      <li>The Accumulator Will Be <code>$8967</code></li>
      <li>The N Flag Will Be 0</li>
      <li>The Z Flag Will Be 0</li>
    </ul>
  </section>
  <section>
    <h3><a id="6.10.4" name="6.10.4">6.10.4
    <code>XCE</code></a></h3>
    <pre>
eXchange Carry and Emulation flags
</pre>
    <table class="opcode">
      <thead>
        <tr>
          <th>OP</th>
          <th>LEN</th>
          <th>CYCLES</th>
          <th>MODE</th>
          <th>nvmxdizc e</th>
          <th>SYNTAX</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>FB</td>
          <td>1</td>
          <td>2</td>
          <td>imp</td>
          <td>.......* *</td>
          <td>XCE</td>
        </tr>
      </tbody>
    </table>
    <p class="added"><code>XCE</code> exchanges (i.e. swaps) the c
    and e flags. This is the only instruction that changes the
    value of the e flag. Note that when the e flag is 1, the m and
    x flags are forced to 1 (and consequently the XH and YH
    registers are forced to <code>$00</code>), and the SH register
    is forced to <code>$01</code>.</p>
    <p>Example: If the c flag is 0 and the e flag is 1, then after
    an <code>XCE</code></p>
    <ul>
      <li>The C Flag Will Be 1</li>
      <li>The E Flag Will Be 0</li>
    </ul>
  </section>
  <section>
    <h3><a id="APPENDIX:" name="APPENDIX:">Appendix: Emulation
    Mode</a></h3>
    <p>The sections above which described the addressing modes and
    instructions also covered emulation mode. However, there are
    several points about emulation mode worth emphasizing.</p>
    <p>To begin with, emulation mode has slightly different
    behavior than 8-bit (i.e. when the m and x flags are both 1)
    native mode. For instance, when updating an NMOS 6502 or 65C02
    routine (or program) for 16-bit data, you may find it helpful
    to get it working in 8-bit native mode first, then modify it
    for 16-bit mode. The two biggest differences are (a) emulation
    mode has direct page wrap around (when DL is <code>$00</code>,
    which is typically the case), but native mode does not, and (b)
    after a <code>TXS</code>, in emulation mode, the stack is on
    page 1 (since SH is forced to <code>$01</code>), but in 8-bit
    native mode, <code>TXS</code> transfers all 16 bits of the X
    register (since the S register is 16 bits wide) thus the stack
    is then on page 0 (since XH is forced to <code>$00</code> when
    the x flag is 1).</p>
    <p>There are also minor differences. In native mode,
    <code>RTI</code> pulls 4 bytes (versus 3 in emulation mode).
    This is not a problem for interrupts, since 4 bytes are pushed
    in native mode, but some monitor/debugger programs use
    <code>RTI</code> to prepare the flags and then jump to a
    user-specified address (on the stack). Another difference is
    that in emulation mode, a branch taken to a different page
    takes 4 cycles, but in native mode it takes 3 cycles (except
    <code>BRL</code>) regardless of whether a page boundary is
    crossed or not. This is almost never an issue since routines
    which depend on exact timing are generally located at an
    address specifically chosen so that page boundary crossings
    will not occur (and thus a branch taken is 3 cycles in both
    emulation and native mode).</p>
    <p>Something else that was not explicitly stated above is that
    "new" (again, "new" meaning "not present on the 65C02")
    addressing modes and instructions are functional (i.e. not
    NOPs) in emulation mode, and in most cases can be useful. (One
    exception is the block move instructions, <code>MVN</code> and
    <code>MVP</code>, which are of limited use in emulation mode,
    since the high byte of the X and Y register is forced to
    <code>$00</code>.) Why use "new" addressing modes and/or
    instructions in emulation mode? While the 65C816 has 24-bit
    addresses and 16-bit data, there are some useful subsets. Using
    16-bit addresses and 16-bit data simplifies address decoding
    circuitry. Using 24-bit addresses and 8-bit data can also be
    useful (as long as there isn't much 16-bit calculation), since
    most instructions are faster when operating on 8-bit data, and
    8-bit immediate data takes less space; thus it's as though the
    system is a 65C02 with a larger address space. With emulation
    mode, you can have 24-bit addresses, 8-bit data, and direct
    page wrap around.</p>
    <p>However, because "new" addressing modes and/or instructions
    were intended for native mode, they do not incorporate behavior
    that is specific to emulation mode such as page wrap around.
    For example, if the D register is <code>$0000</code> (and the e
    flag is 1), then <code>LDA ($FF)</code> uses a pointer whose
    low byte is at <code>$0000FF</code> and whose high byte is at
    <code>$000000</code> (like the 65C02), but <code>PEI</code>
    <code>$FF</code> pushes a 16-bit value whose low byte is at
    <code>$0000FF</code> and whose high byte is at
    <code>$000100</code>.</p>
    <p>Page 1 wrap around of the stack is similar. For example,
    when the S register is <code>$0100</code> (and the e flag is
    1), then <code>PHP</code> pushes the P register to
    <code>$000100</code>, leaving the S register
    <code>$0001FF</code>; a subsequent <code>PLP</code> pulls the P
    register from <code>$000100</code>, leaving the S register at
    <code>$000100</code>. By contrast, replacing <code>PHP</code>
    and <code>PLP</code> with <code>PHB</code> and <code>PLB</code>
    in the preceding example, <code>PHB</code> pushes to
    <code>$000100</code> (like <code>PHP</code>), but
    <code>PLB</code> pulls from <code>$000200</code>.
    <code>PEA</code>, when the S register is <code>$0100</code>
    (and the e flag is 1), has similar behavior; it pushes the high
    byte to <code>$000100</code>, the low byte to
    <code>$0000FF</code>, and leaves the stack pointer at
    <code>$0001FE</code>. Likewise for other "new" instructions
    that push to, and pull from, the stack. <code>JSR</code>
    (absolute,X) is "new", even though <code>JSR</code> was present
    on the 65C02 (with absolute addressing) and (absolute,X)
    addressing is available on the 65C02 (with <code>JMP</code>),
    since that combination of instruction and addressing mode was
    not available on the 65C02. Generally, page 1 wrap around is
    not an issue, since the stack pointer is frequently initialized
    (despite the fact that this is often unnecessary) to
    <code>$01FF</code> on the NMOS 6502 and 65C02, so the stack
    pointer won't be near <code>$0100</code> when pushing or
    <code>$01FF</code> when pulling.</p>
    <p>Another interesting fact is that direct page wrapping occurs
    (in emulation mode) when the DL register is <code>$00</code>;
    the DH register need not be zero. In fact, this can be very
    useful, since it allows you locate the direct page on any bank
    0 page. For instance, if you have a program that makes heavy
    use of the direct page (e.g. a programming language
    interpreter, like BASIC, or an operating system) and you wish
    to avoid zero page conflicts with I/O routines, then you can
    adjust the D register when calling an I/O routine so that the
    program and the I/O routines use different pages for the direct
    page.</p>
    <p>If, for whatever reason, you do not wish to have direct page
    wrap around in emulation mode, it will not occur when the DL
    register is nonzero.</p>
    <p>Finally, emulation mode code does not have to be in bank 0,
    as long as there are no interrupts. As noted in sections 6.3.1,
    6.3.1.1, and 6.3.2, interrupts do not push (and
    <code>RTI</code> does not pull) the bank byte on the stack, but
    as long as you can guarantee that interrupts will not occur
    when in a nonzero bank (other than RESET, since you wouldn't
    return from that), then nonzero banks can be used for code as
    well as data.</p>
    <p><span class="c2">Last Updated September 28, 2015.</span></p>
  </section>
</body>
</html>
